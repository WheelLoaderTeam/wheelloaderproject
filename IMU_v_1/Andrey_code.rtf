{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff31507\deff0\stshfdbch31505\stshfloch31506\stshfhich31506\stshfbi31507\deflang1053\deflangfe1053\themelang1053\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f37\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}{\flomajor\f31500\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbmajor\f31501\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhimajor\f31502\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria;}
{\fbimajor\f31503\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\flominor\f31504\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbminor\f31505\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhiminor\f31506\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}
{\fbiminor\f31507\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f39\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f40\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f42\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f43\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f44\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f45\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f46\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f47\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f39\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f40\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f42\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f43\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f44\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f45\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f46\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f47\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f409\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}{\f410\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}
{\f412\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\f413\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}{\f416\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}{\f417\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}
{\flomajor\f31508\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flomajor\f31509\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flomajor\f31511\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\flomajor\f31512\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flomajor\f31513\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flomajor\f31514\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\flomajor\f31515\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flomajor\f31516\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbmajor\f31518\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fdbmajor\f31519\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbmajor\f31521\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbmajor\f31522\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fdbmajor\f31523\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbmajor\f31524\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbmajor\f31525\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fdbmajor\f31526\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhimajor\f31528\fbidi \froman\fcharset238\fprq2 Cambria CE;}{\fhimajor\f31529\fbidi \froman\fcharset204\fprq2 Cambria Cyr;}
{\fhimajor\f31531\fbidi \froman\fcharset161\fprq2 Cambria Greek;}{\fhimajor\f31532\fbidi \froman\fcharset162\fprq2 Cambria Tur;}{\fhimajor\f31535\fbidi \froman\fcharset186\fprq2 Cambria Baltic;}
{\fhimajor\f31536\fbidi \froman\fcharset163\fprq2 Cambria (Vietnamese);}{\fbimajor\f31538\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbimajor\f31539\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbimajor\f31541\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbimajor\f31542\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbimajor\f31543\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbimajor\f31544\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbimajor\f31545\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbimajor\f31546\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\flominor\f31548\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flominor\f31549\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flominor\f31551\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\flominor\f31552\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flominor\f31553\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flominor\f31554\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\flominor\f31555\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flominor\f31556\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbminor\f31558\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fdbminor\f31559\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbminor\f31561\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbminor\f31562\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fdbminor\f31563\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbminor\f31564\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbminor\f31565\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fdbminor\f31566\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhiminor\f31568\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}{\fhiminor\f31569\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}
{\fhiminor\f31571\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\fhiminor\f31572\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}{\fhiminor\f31575\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}
{\fhiminor\f31576\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\fbiminor\f31578\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbiminor\f31579\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbiminor\f31581\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbiminor\f31582\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbiminor\f31583\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbiminor\f31584\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbiminor\f31585\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbiminor\f31586\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\*\defchp \fs22\loch\af31506\hich\af31506\dbch\af31505 }{\*\defpap \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 }\noqfpromote {\stylesheet{\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 
\ltrch\fcs0 \fs22\lang1053\langfe1053\loch\f31506\hich\af31506\dbch\af31505\cgrid\langnp1053\langfenp1053 \snext0 \sqformat \spriority0 Normal;}{\*\cs10 \additive \ssemihidden \sunhideused \spriority1 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 \fs22\lang1053\langfe1053\loch\f31506\hich\af31506\dbch\af31505\cgrid\langnp1053\langfenp1053 \snext11 \ssemihidden \sunhideused 
Normal Table;}{\s15\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 \fs22\lang1053\langfe1053\loch\f31506\hich\af31506\dbch\af31505\cgrid\langnp1053\langfenp1053 
\snext15 \sqformat \spriority1 \styrsid855868 No Spacing;}}{\*\rsidtbl \rsid855868\rsid3031795\rsid10226726\rsid14514414}{\mmathPr\mmathFont34\mbrkBin0\mbrkBinSub0\msmallFrac0\mdispDef1\mlMargin0\mrMargin0\mdefJc1\mwrapIndent1440\mintLim0\mnaryLim1}{\info
{\operator lab}{\creatim\yr2013\mo11\dy27\hr8\min33}{\revtim\yr2013\mo11\dy27\hr8\min52}{\version4}{\edmins19}{\nofpages22}{\nofwords6158}{\nofchars32642}{\nofcharsws38723}{\vern49167}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wo
rdml}}\paperw12240\paperh15840\margl1417\margr1417\margt1417\margb1417\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\hyphhotz425\trackmoves0\trackformatting1\donotembedsysfont0\relyonvml0\donotembedlingdata1\grfdocevents0\validatexml0\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors0\horzdoc\dghspace120\dgvspace120
\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100\rsidroot855868 \fet0{\*\wgrffmtfilter 2450}\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}
{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}
{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9
\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\s15\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid855868 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 
\fs22\lang1053\langfe1053\loch\af31506\hich\af31506\dbch\af31505\cgrid\langnp1053\langfenp1053 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506   42 */
\par \hich\af31506\dbch\af31505\loch\f31506   43 
\par \hich\af31506\dbch\af31505\loch\f31506   44 /**
\par \hich\af31506\dbch\af31505\loch\f31506   45  *   \\addtogroup wireless
\par \hich\af31506\dbch\af31505\loch\f31506   46  *  @\{
\par \hich\af31506\dbch\af31505\loch\f31506   47 */
\par \hich\af31506\dbch\af31505\loch\f31506   48 
\par \hich\af31506\dbch\af31505\loch\f31506   49 /**
\par \hich\af31506\dbch\af31505\loch\f31506   50  *   \\defgroup hal RF230 hardware level drivers
\par \hich\af31506\dbch\af31505\loch\f31506   51  *   @\{
\par \hich\af31506\dbch\af31505\loch\f31506   52  */
\par \hich\af31506\dbch\af31505\loch\f31506   53 
\par \hich\af31506\dbch\af31505\loch\f31506   54 /**
\par \hich\af31506\dbch\af31505\loch\f31506   55  *  \\file
\par \hich\af31506\dbch\af31505\loch\f31506   56  *  This file contains low-level radio driver code.
\par \hich\af31506\dbch\af31505\loch\f31506   57  *  This version is optimized for use with the "barebones" RF230b\hich\af31506\dbch\af31505\loch\f31506 b driver,
\par \hich\af31506\dbch\af31505\loch\f31506   58  *  which communicates directly with the contiki core MAC layer.
\par \hich\af31506\dbch\af31505\loch\f31506   59  *  It is optimized for speed at the expense of generality.
\par \hich\af31506\dbch\af31505\loch\f31506   60  */
\par \hich\af31506\dbch\af31505\loch\f31506   61 #include "contiki-conf.h"
\par \hich\af31506\dbch\af31505\loch\f31506   62 #if DEBUGFLOWSIZE
\par \hich\af31506\dbch\af31505\loch\f31506   63 extern uint8_t debugflowsize,debugflow[DEBUGFLOWSIZE];
\par \hich\af31506\dbch\af31505\loch\f31506   64 #define DEBUGFLOW(c) if (debugflowsize<(DEBUGFLOWSIZE-1)) debugflow[debugflowsize++]=c
\par \hich\af31506\dbch\af31505\loch\f31506   65 #else
\par \hich\af31506\dbch\af31505\loch\f31506   66 #define DEBUGFLOW(c)
\par \hich\af31506\dbch\af31505\loch\f31506   67 #endif
\par \hich\af31506\dbch\af31505\loch\f31506   68 
\par \hich\af31506\dbch\af31505\loch\f31506   69 /* rf230interruptflag can be printed in the \hich\af31506\dbch\af31505\loch\f31506 main idle loop for debugging */
\par \hich\af31506\dbch\af31505\loch\f31506   70 #define DEBUG 0
\par \hich\af31506\dbch\af31505\loch\f31506   71 #if DEBUG
\par \hich\af31506\dbch\af31505\loch\f31506   72 volatile char rf230interruptflag;
\par \hich\af31506\dbch\af31505\loch\f31506   73 #define INTERRUPTDEBUG(arg) rf230interruptflag=arg
\par \hich\af31506\dbch\af31505\loch\f31506   74 #include "stdio.h"
\par \hich\af31506\dbch\af31505\loch\f31506   75 #define PRINTF(...) printf(__VA_ARGS__)
\par \hich\af31506\dbch\af31505\loch\f31506   76 #else
\par \hich\af31506\dbch\af31505\loch\f31506   77 #define \hich\af31506\dbch\af31505\loch\f31506 PRINTF(...)
\par \hich\af31506\dbch\af31505\loch\f31506   78 #define INTERRUPTDEBUG(arg)
\par \hich\af31506\dbch\af31505\loch\f31506   79 #endif
\par \hich\af31506\dbch\af31505\loch\f31506   80 
\par \hich\af31506\dbch\af31505\loch\f31506   81 /*============================ INCLUDE =======================================*/
\par \hich\af31506\dbch\af31505\loch\f31506   82 #include <stdlib.h>
\par \hich\af31506\dbch\af31505\loch\f31506   83 
\par \hich\af31506\dbch\af31505\loch\f31506   84 #include "hal.h"
\par \hich\af31506\dbch\af31505\loch\f31506   85 
\par \hich\af31506\dbch\af31505\loch\f31506   86 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506  87 #include <avr/io.h>
\par \hich\af31506\dbch\af31505\loch\f31506   88 #include "atmega128rfa1_registermap.h"
\par \hich\af31506\dbch\af31505\loch\f31506   89 #else
\par \hich\af31506\dbch\af31505\loch\f31506   90 #include "at86rf230_registermap.h"
\par \hich\af31506\dbch\af31505\loch\f31506   91 #endif
\par \hich\af31506\dbch\af31505\loch\f31506   92 
\par \hich\af31506\dbch\af31505\loch\f31506   93 /*============================ VARIABLES =====================================*/
\par \hich\af31506\dbch\af31505\loch\f31506   94 /** \\brief This is a file in\hich\af31506\dbch\af31505\loch\f31506 ternal variable that contains the 16 MSB of the
\par \hich\af31506\dbch\af31505\loch\f31506   95  *         system time.
\par \hich\af31506\dbch\af31505\loch\f31506   96  *
\par \hich\af31506\dbch\af31505\loch\f31506   97  *         The system time (32-bit) is the current time in microseconds. For the
\par \hich\af31506\dbch\af31505\loch\f31506   98  *         AVR microcontroller implementation this is solved by using a 16-bit
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506  99  *         timer (Timer1) with a clock frequency of 1MHz. The hal_system_time is
\par \hich\af31506\dbch\af31505\loch\f31506  100  *         incremented when the 16-bit timer overflows, representing the 16 MSB.
\par \hich\af31506\dbch\af31505\loch\f31506  101  *         The timer value it self (TCNT1) is then the 16 LSB.
\par \hich\af31506\dbch\af31505\loch\f31506  102  *
\par \hich\af31506\dbch\af31505\loch\f31506  103  *  \\\hich\af31506\dbch\af31505\loch\f31506 see hal_get_system_time
\par \hich\af31506\dbch\af31505\loch\f31506  104  */
\par \hich\af31506\dbch\af31505\loch\f31506  105 static uint16_t hal_system_time = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  106 volatile extern signed char rf230_last_rssi;
\par \hich\af31506\dbch\af31505\loch\f31506  107 
\par \hich\af31506\dbch\af31505\loch\f31506  108 //static uint8_t volatile hal_bat_low_flag;
\par \hich\af31506\dbch\af31505\loch\f31506  109 //static uint8_t volatile hal_pll_lock_flag;
\par \hich\af31506\dbch\af31505\loch\f31506  110 
\par \hich\af31506\dbch\af31505\loch\f31506  111 /*============\hich\af31506\dbch\af31505\loch\f31506 ================ CALLBACKS =====================================*/
\par \hich\af31506\dbch\af31505\loch\f31506  112 
\par \hich\af31506\dbch\af31505\loch\f31506  113 /** \\brief This function is called when a rx_start interrupt is signaled.
\par \hich\af31506\dbch\af31505\loch\f31506  114  *
\par \hich\af31506\dbch\af31505\loch\f31506  115  *         If this function pointer is set to something else than NULL, it will
\par \hich\af31506\dbch\af31505\loch\f31506  116  *         be called when a RX_START event is signaled. The function takes two
\par \hich\af31506\dbch\af31505\loch\f31506  117  *         parameters: timestamp in IEEE 802.15.4 symbols (16 us resolution) and
\par \hich\af31506\dbch\af31505\loch\f31506  118  *         frame length. The event handler will be called in the interrupt domain,
\par \hich\af31506\dbch\af31505\loch\f31506  119  *         so the function must be kept short and not be blocking! Otherwise the
\par \hich\af31506\dbch\af31505\loch\f31506  120  *         system performance will be greatly degraded.
\par \hich\af31506\dbch\af31505\loch\f31506  121  *
\par \hich\af31506\dbch\af31505\loch\f31506  122  *  \\see hal_set_rx_start_event_handler
\par \hich\af31506\dbch\af31505\loch\f31506  123  */
\par \hich\af31506\dbch\af31505\loch\f31506  124 //static hal_rx_start_isr_event_handler_\hich\af31506\dbch\af31505\loch\f31506 t rx_start_callback;
\par \hich\af31506\dbch\af31505\loch\f31506  125 
\par \hich\af31506\dbch\af31505\loch\f31506  126 /** \\brief This function is called when a trx_end interrupt is signaled.
\par \hich\af31506\dbch\af31505\loch\f31506  127  *
\par \hich\af31506\dbch\af31505\loch\f31506  128  *         If this function pointer is set to something else than NULL, it will
\par \hich\af31506\dbch\af31505\loch\f31506  129  *         be called when a TRX_END event is signaled\hich\af31506\dbch\af31505\loch\f31506 . The function takes one
\par \hich\af31506\dbch\af31505\loch\f31506  130  *         parameter: timestamp in IEEE 802.15.4 symbols (16 us resolution).
\par \hich\af31506\dbch\af31505\loch\f31506  131  *         The event handler will be called in the interrupt domain,
\par \hich\af31506\dbch\af31505\loch\f31506  132  *         so the function must not block!
\par \hich\af31506\dbch\af31505\loch\f31506  133  *
\par \hich\af31506\dbch\af31505\loch\f31506  134  *  \\see hal_s\hich\af31506\dbch\af31505\loch\f31506 et_trx_end_event_handler
\par \hich\af31506\dbch\af31505\loch\f31506  135  */
\par \hich\af31506\dbch\af31505\loch\f31506  136 //static hal_trx_end_isr_event_handler_t trx_end_callback;
\par \hich\af31506\dbch\af31505\loch\f31506  137 
\par \hich\af31506\dbch\af31505\loch\f31506  138 /*============================ IMPLEMENTATION ================================*/
\par \hich\af31506\dbch\af31505\loch\f31506  139 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  140 //#include <avr/io.h>
\par \hich\af31506\dbch\af31505\loch\f31506  141 #include <avr/interrupt.h>
\par \hich\af31506\dbch\af31505\loch\f31506  142 /* AVR1281 with internal RF231 radio */
\par \hich\af31506\dbch\af31505\loch\f31506  143 #define HAL_SPI_TRANSFER_OPEN() 
\par \hich\af31506\dbch\af31505\loch\f31506  144 //#define HAL_SPI_TRANSFER_WRITE(to_write) (SPDR = (to_write))
\par \hich\af31506\dbch\af31505\loch\f31506  145 #define HAL_SPI}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid14514414 
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 _TRANSFER_WAIT()
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506 146 #define HAL_SPI_TRANSFER_READ() (SPDR)
\par \hich\af31506\dbch\af31505\loch\f31506  147 #define HAL_SPI_TRANSFER_CLOSE()
\par \hich\af31506\dbch\af31505\loch\f31506  148 #if 0
\par \hich\af31506\dbch\af31505\loch\f31506  149 #define HAL_SPI_TRANSFER(to_write) (      \\
\par \hich\af31506\dbch\af31505\loch\f31506  150                                     HAL_SPI_TRANSFER_WRITE(to_write),   \\
\par \hich\af31506\dbch\af31505\loch\f31506  151                                \hich\af31506\dbch\af31505\loch\f31506      HAL_SPI_TRANSFER_WAIT(),            \\
\par \hich\af31506\dbch\af31505\loch\f31506  152                                     HAL_SPI_TRANSFER_READ() )
\par \hich\af31506\dbch\af31505\loch\f31506  153 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  154 #elif defined(__AVR__)
\par \hich\af31506\dbch\af31505\loch\f31506  155 /*
\par \hich\af31506\dbch\af31505\loch\f31506  156  * AVR with hardware SPI tranfers (TODO: move to hw spi hal for avr cpu)
\par \hich\af31506\dbch\af31505\loch\f31506  157  */
\par \hich\af31506\dbch\af31505\loch\f31506  158 #inclu\hich\af31506\dbch\af31505\loch\f31506 de <avr/io.h>
\par \hich\af31506\dbch\af31505\loch\f31506  159 #include <avr/interrupt.h>
\par \hich\af31506\dbch\af31505\loch\f31506  160 
\par \hich\af31506\dbch\af31505\loch\f31506  161 #define HAL_SPI_TRANSFER_OPEN() \{ \\
\par \hich\af31506\dbch\af31505\loch\f31506  162   HAL_ENTER_CRITICAL_REGION();    \\
\par \hich\af31506\dbch\af31505\loch\f31506  163   HAL_SS_LOW(); /* Start the SPI transaction by pulling the Slave Select low. */
\par \hich\af31506\dbch\af31505\loch\f31506  164 #define HAL_SPI_TRANSFER_WRITE(\hich\af31506\dbch\af31505\loch\f31506 to_write) (SPDR = (to_write))
\par \hich\af31506\dbch\af31505\loch\f31506  165 #define HAL_SPI_TRANSFER_WAIT() (\{while ((SPSR & (1 << SPIF)) == 0) \{;\}\}) /* gcc extension, alternative inline function */
\par \hich\af31506\dbch\af31505\loch\f31506  166 #define HAL_SPI_TRANSFER_READ() (SPDR)
\par \hich\af31506\dbch\af31505\loch\f31506  167 #define HAL_SPI_TRANSFER_CLOSE() \\
\par \hich\af31506\dbch\af31505\loch\f31506  168     HAL_S\hich\af31506\dbch\af31505\loch\f31506 S_HIGH(); /* End the transaction by pulling the Slave Select High. */ \\
\par \hich\af31506\dbch\af31505\loch\f31506  169     HAL_LEAVE_CRITICAL_REGION(); \\
\par \hich\af31506\dbch\af31505\loch\f31506  170     \}
\par \hich\af31506\dbch\af31505\loch\f31506  171 #define HAL_SPI_TRANSFER(to_write) (      \\
\par \hich\af31506\dbch\af31505\loch\f31506  172                                     HAL_SPI_TRANSFER_WRITE(to_write),   \\
\par \hich\af31506\dbch\af31505\loch\f31506  173                                     HAL_SPI_TRANSFER_WAIT(),            \\
\par \hich\af31506\dbch\af31505\loch\f31506  174                                     HAL_SPI_TRANSFER_READ() )
\par \hich\af31506\dbch\af31505\loch\f31506  175 
\par \hich\af31506\dbch\af31505\loch\f31506  176 #else /* __AVR__ */
\par \hich\af31506\dbch\af31505\loch\f31506  177 /*
\par \hich\af31506\dbch\af31505\loch\f31506  178  * Other SPI architecture (parts to core, parts to m16c6Xp 
\par \hich\af31506\dbch\af31505\loch\f31506  179  \hich\af31506\dbch\af31505\loch\f31506 */
\par \hich\af31506\dbch\af31505\loch\f31506  180 #include "contiki-mulle.h" // MULLE_ENTER_CRITICAL_REGION
\par \hich\af31506\dbch\af31505\loch\f31506  181 
\par \hich\af31506\dbch\af31505\loch\f31506  182 #define HAL_SPI_TRANSFER_OPEN() \{ \\
\par \hich\af31506\dbch\af31505\loch\f31506  183         HAL_ENTER_CRITICAL_REGION();      \\
\par \hich\af31506\dbch\af31505\loch\f31506  184         HAL_SS_LOW(); /* Start the SPI transaction by pulling the Slave Select low. */
\par \hich\af31506\dbch\af31505\loch\f31506  1\hich\af31506\dbch\af31505\loch\f31506 85 #define HAL_SPI_TRANSFER_WRITE(to_write) (U0TB.BYTE.U0TBL = to_write)
\par \hich\af31506\dbch\af31505\loch\f31506  186 #define HAL_SPI_TRANSFER_WAIT()  while( !U0C1.BIT.RI )
\par \hich\af31506\dbch\af31505\loch\f31506  187 #define HAL_SPI_TRANSFER_READ() (U0RB.BYTE.U0RBL)
\par \hich\af31506\dbch\af31505\loch\f31506  188 #define HAL_SPI_TRANSFER_CLOSE() \\
\par \hich\af31506\dbch\af31505\loch\f31506  189     HAL_SS_HIGH(); /* E\hich\af31506\dbch\af31505\loch\f31506 nd the transaction by pulling the Slave Select High. */ \\
\par \hich\af31506\dbch\af31505\loch\f31506  190     HAL_LEAVE_CRITICAL_REGION(); \\
\par \hich\af31506\dbch\af31505\loch\f31506  191     \}
\par \hich\af31506\dbch\af31505\loch\f31506  192 uint8_t HAL_SPI_TRANSFER(to_write) \{
\par \hich\af31506\dbch\af31505\loch\f31506  193         HAL_SPI_TRANSFER_WRITE(to_write);
\par \hich\af31506\dbch\af31505\loch\f31506  194         HAL_SPI_TRANSFER_WAIT();
\par \hich\af31506\dbch\af31505\loch\f31506  195         return \hich\af31506\dbch\af31505\loch\f31506 HAL_SPI_TRANSFER_READ();
\par \hich\af31506\dbch\af31505\loch\f31506  196 \}
\par \hich\af31506\dbch\af31505\loch\f31506  197 
\par \hich\af31506\dbch\af31505\loch\f31506  198 #endif  /* !__AVR__ */
\par \hich\af31506\dbch\af31505\loch\f31506  199  
\par \hich\af31506\dbch\af31505\loch\f31506  200 /** \\brief  This function initializes the Hardware Abstraction Layer.
\par \hich\af31506\dbch\af31505\loch\f31506  201  */
\par \hich\af31506\dbch\af31505\loch\f31506  202 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  203 //#define HAL_RF230_ISR() ISR(RADIO_VECT)
\par \hich\af31506\dbch\af31505\loch\f31506  204 #define HAL_TIME_ISR()  ISR(TIMER1_OVF_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  205 #define HAL_TICK_UPCNT() (TCNT1)
\par \hich\af31506\dbch\af31505\loch\f31506  206 void
\par \hich\af31506\dbch\af31505\loch\f31506  207 hal_init(void)
\par \hich\af31506\dbch\af31505\loch\f31506  208 \{
\par \hich\af31506\dbch\af31505\loch\f31506  209     /*Reset variables used in file.*/
\par \hich\af31506\dbch\af31505\loch\f31506  210     hal_system_time = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  211  //   TCCR1B = HAL_TCCR1B_CONFIG;       /* Set clock \hich\af31506\dbch\af31505\loch\f31506 prescaler */
\par \hich\af31506\dbch\af31505\loch\f31506  212  //   TIFR1 |= (1 << ICF1);             /* Clear Input Capture Flag. */
\par \hich\af31506\dbch\af31505\loch\f31506  213  //   HAL_ENABLE_OVERFLOW_INTERRUPT(); /* Enable Timer1 overflow interrupt. */
\par \hich\af31506\dbch\af31505\loch\f31506  214     //hal_enable_trx_interrupt();    /* NOT USED: Enable interrupt pin from t\hich\af31506\dbch\af31505\loch\f31506 he radio transceiver. */
\par \hich\af31506\dbch\af31505\loch\f31506  215 \}
\par \hich\af31506\dbch\af31505\loch\f31506  216 
\par \hich\af31506\dbch\af31505\loch\f31506  217 #elif defined(__AVR__)
\par \hich\af31506\dbch\af31505\loch\f31506  218 #define HAL_RF230_ISR() ISR(RADIO_VECT)
\par \hich\af31506\dbch\af31505\loch\f31506  219 #define HAL_TIME_ISR()  ISR(TIMER1_OVF_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  220 #define HAL_TICK_UPCNT() (TCNT1)
\par \hich\af31506\dbch\af31505\loch\f31506  221 void
\par \hich\af31506\dbch\af31505\loch\f31506  222 hal_init(void)
\par \hich\af31506\dbch\af31505\loch\f31506  223 \{
\par \hich\af31506\dbch\af31505\loch\f31506  224     /*Reset var\hich\af31506\dbch\af31505\loch\f31506 iables used in file.*/
\par \hich\af31506\dbch\af31505\loch\f31506  225     hal_system_time = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  226 //  hal_reset_flags();
\par \hich\af31506\dbch\af31505\loch\f31506  227 
\par \hich\af31506\dbch\af31505\loch\f31506  228     /*IO Specific Initialization - sleep and reset pins. */
\par \hich\af31506\dbch\af31505\loch\f31506  229     /* Set pins low before they are initialized as output? Does not seem to matter */
\par \hich\af31506\dbch\af31505\loch\f31506  230 //  hal_set_rst_low();
\par \hich\af31506\dbch\af31505\loch\f31506  231 //  hal_set_slptr_low();
\par \hich\af31506\dbch\af31505\loch\f31506  232     DDR_SLP_TR |= (1 << SLP_TR); /* Enable SLP_TR as output. */
\par \hich\af31506\dbch\af31505\loch\f31506  233     DDR_RST    |= (1 << RST);    /* Enable RST as output. */
\par \hich\af31506\dbch\af31505\loch\f31506  234 
\par \hich\af31506\dbch\af31505\loch\f31506  235     /*}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid14514414 
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506  Specific Initialization.*/
\par \hich\af31506\dbch\af31505\loch\f31506  236     /* Set\hich\af31506\dbch\af31505\loch\f31506  SS, CLK and MOSI as output. */
\par \hich\af31506\dbch\af31505\loch\f31506  237     /* To avoid a SPI glitch, the port register shall be set before the DDR register */ 
\par \hich\af31506\dbch\af31505\loch\f31506  238     HAL_PORT_SPI |= (1 << HAL_DD_SS) | (1 << HAL_DD_SCK); /* Set SS and CLK high */
\par \hich\af31506\dbch\af31505\loch\f31506  239     HAL_DDR_SPI  |= (1 << HAL_DD_SS)\hich\af31506\dbch\af31505\loch\f31506  | (1 << HAL_DD_SCK) | (1 << HAL_DD_MOSI);
\par \hich\af31506\dbch\af31505\loch\f31506  240     HAL_DDR_SPI  &=~ (1<< HAL_DD_MISO);                   /* MISO input */ 
\par \hich\af31506\dbch\af31505\loch\f31506  241 
\par \hich\af31506\dbch\af31505\loch\f31506  242     /* Run SPI at max speed */
\par \hich\af31506\dbch\af31505\loch\f31506  243     SPCR         = (1 << SPE) | (1 << MSTR); /* Enable SPI module and master operatio\hich\af31506\dbch\af31505\loch\f31506 n. */
\par \hich\af31506\dbch\af31505\loch\f31506  244     SPSR         = (1 << SPI2X); /* Enable doubled SPI speed in master mode. */
\par \hich\af31506\dbch\af31505\loch\f31506  245 
\par \hich\af31506\dbch\af31505\loch\f31506  246     /*TIMER1 Specific Initialization.*/
\par \hich\af31506\dbch\af31505\loch\f31506  247     TCCR1B = HAL_TCCR1B_CONFIG;       /* Set clock prescaler */
\par \hich\af31506\dbch\af31505\loch\f31506  248     TIFR1 |= (1 << ICF1);             /*\hich\af31506\dbch\af31505\loch\f31506  Clear Input Capture Flag. */
\par \hich\af31506\dbch\af31505\loch\f31506  249     HAL_ENABLE_OVERFLOW_INTERRUPT(); /* Enable Timer1 overflow interrupt. */
\par \hich\af31506\dbch\af31505\loch\f31506  250     hal_enable_trx_interrupt();    /* Enable interrupts from the radio transceiver. */
\par \hich\af31506\dbch\af31505\loch\f31506  251 \}
\par \hich\af31506\dbch\af31505\loch\f31506  252 
\par \hich\af31506\dbch\af31505\loch\f31506  253 #else /* __AVR__ */
\par \hich\af31506\dbch\af31505\loch\f31506  254 
\par \hich\af31506\dbch\af31505\loch\f31506  255 #define HAL_RF230_ISR() M16C_INTERRUPT(M16C_INT1)
\par \hich\af31506\dbch\af31505\loch\f31506  256 #define HAL_TIME_ISR()  M16C_INTERRUPT(M16C_TMRB4)
\par \hich\af31506\dbch\af31505\loch\f31506  257 #define HAL_TICK_UPCNT() (0xFFFF-TB4) // TB4 counts down so we need to convert it to upcounting
\par \hich\af31506\dbch\af31505\loch\f31506  258 
\par \hich\af31506\dbch\af31505\loch\f31506  259 void
\par \hich\af31506\dbch\af31505\loch\f31506  260 hal_init(void)
\par \hich\af31506\dbch\af31505\loch\f31506  261 \{
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506 262         PRINTF("Init hal radio\\n");
\par \hich\af31506\dbch\af31505\loch\f31506  263     /*Reset variables used in file.*/
\par \hich\af31506\dbch\af31505\loch\f31506  264     hal_system_time = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  265 
\par \hich\af31506\dbch\af31505\loch\f31506  266     /*IO Specific Initialization - sleep and reset pins. */
\par \hich\af31506\dbch\af31505\loch\f31506  267     PD0.BIT.PD0_7 = 1; // Sleep pin
\par \hich\af31506\dbch\af31505\loch\f31506  268     PD4.BIT.PD4_3 = 1; // \hich\af31506\dbch\af31505\loch\f31506 Reset pin
\par \hich\af31506\dbch\af31505\loch\f31506  269     PD8.BIT.PD8_3 = 0; // Radio IRQ
\par \hich\af31506\dbch\af31505\loch\f31506  270 
\par \hich\af31506\dbch\af31505\loch\f31506  271     /*SPI Specific Initialization.*/
\par \hich\af31506\dbch\af31505\loch\f31506  272     /* Set SS, CLK and MOSI as output. }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 */
\par \hich\af31506\dbch\af31505\loch\f31506  273     PD6.BIT.PD6_2 = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  274     PD6.BIT.PD6_3 = 1;
\par \hich\af31506\dbch\af31505\loch\f31506  275     PD6.BIT.PD6_1 = 1;
\par \hich\af31506\dbch\af31505\loch\f31506  276     PD3.BIT.PD3_5 = 1\hich\af31506\dbch\af31505\loch\f31506 ;
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 277 
\par \hich\af31506\dbch\af31505\loch\f31506  278     /* Set SS */
\par \hich\af31506\dbch\af31505\loch\f31506  279     P3.BIT.P3_5 = 1;
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 280 
\par \hich\af31506\dbch\af31505\loch\f31506  281     U0SMR2.BYTE = 0x00;            // not I2C mode
\par \hich\af31506\dbch\af31505\loch\f31506  282     U0SMR.BYTE = 0x00;             //    ditto
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 283     U0MR.BYTE   = 0x01;            // internal clock, synchronous mode

\par \hich\af31506\dbch\af31505\loch\f31506  284     U0SMR3.BYTE = 0x02;
\par \hich\af31506\dbch\af31505\loch\f31506  285     U0C0.BYTE   = 0x90;            // msb first, CKPOL=0, no CTS/RTS, clock is f1
\par \hich\af31506\dbch\af31505\loch\f31506  286     U0C1.BYTE   = 0x00;            // no data reverse, rx & tx disabled
\par \hich\af31506\dbch\af31505\loch\f31506  287     U0BRG = 0x05;             // 16 MHz / 3 MHz - 1 (round\hich\af31506\dbch\af31505\loch\f31506  up)
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 288     U0C1.BIT.TE = 1;
\par \hich\af31506\dbch\af31505\loch\f31506  289     U0C1.BIT.RE = 1;
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 290 
\par \hich\af31506\dbch\af31505\loch\f31506  291     /*TIMER Specific Initialization.*/
\par \hich\af31506\dbch\af31505\loch\f31506  292     // Init count source (Timer B3)
\par \hich\af31506\dbch\af31505\loch\f31506  293     TB3.WORD = (10 - 1); // 1 us ticks
\par \hich\af31506\dbch\af31505\loch\f31506  294     TB3MR.BYTE = 0b00000000; // Timer mode, F1
\par \hich\af31506\dbch\af31505\loch\f31506  295     TBS\hich\af31506\dbch\af31505\loch\f31506 R.BIT.TB3S = 1; // Start Timer B3
\par \hich\af31506\dbch\af31505\loch\f31506  296 
\par \hich\af31506\dbch\af31505\loch\f31506  297     TB4.WORD = 0xFFFF; //
\par \hich\af31506\dbch\af31505\loch\f31506  298     TB4MR.BYTE = 0b10000001; // Counter mode, count TB3
\par \hich\af31506\dbch\af31505\loch\f31506  299     TBSR.BIT.TB4S = 1; // Start Timer B4
\par \hich\af31506\dbch\af31505\loch\f31506  300 
\par \hich\af31506\dbch\af31505\loch\f31506  301     INT1IC.BYTE = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  302     INT1IC.BIT.POL = 1; // Select rising \hich\af31506\dbch\af31505\loch\f31506 edge
\par \hich\af31506\dbch\af31505\loch\f31506  303     HAL_ENABLE_OVERFLOW_INTERRUPT(); /* Enable Timer overflow interrupt. */
\par \hich\af31506\dbch\af31505\loch\f31506  304     hal_enable_trx_interrupt();
\par \hich\af31506\dbch\af31505\loch\f31506  305 \}
\par \hich\af31506\dbch\af31505\loch\f31506  306 #endif  /* !__AVR__ */
\par \hich\af31506\dbch\af31505\loch\f31506  307 
\par \hich\af31506\dbch\af31505\loch\f31506  308 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  309 /\hich\af31506\dbch\af31505\loch\f31506 ** \\brief  This function reset the interrupt flags and interrupt event handlers
\par \hich\af31506\dbch\af31505\loch\f31506  310  *          (Callbacks) to their default value.
\par \hich\af31506\dbch\af31505\loch\f31506  311  */
\par \hich\af31506\dbch\af31505\loch\f31506  312 //void
\par \hich\af31506\dbch\af31505\loch\f31506  313 //hal_reset_flags(void)
\par \hich\af31506\dbch\af31505\loch\f31506  314 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  315 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  316 
\par \hich\af31506\dbch\af31505\loch\f31506  317     /* Reset Flags. */
\par \hich\af31506\dbch\af31505\loch\f31506  318 //    hal_bat_low_flag     = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  319 //    hal_pll_lock_flag    = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  320 
\par \hich\af31506\dbch\af31505\loch\f31506  321     /* Reset Associated Event Handlers. */
\par \hich\af31506\dbch\af31505\loch\f31506  322 //    rx_start_callback = NULL;
\par \hich\af31506\dbch\af31505\loch\f31506  323 //    trx_end_callback  = NULL;
\par \hich\af31506\dbch\af31505\loch\f31506  324 
\par \hich\af31506\dbch\af31505\loch\f31506  325 //    HAL_LEAVE\hich\af31506\dbch\af31505\loch\f31506 _CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  326 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  327 
\par \hich\af31506\dbch\af31505\loch\f31506  328 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  329 /** \\brief  This function returns the current value of the BAT_LOW flag.
\par \hich\af31506\dbch\af31505\loch\f31506  330  *
\par \hich\af31506\dbch\af31505\loch\f31506  331  *  The BAT_LOW flag is incremented each tim\hich\af31506\dbch\af31505\loch\f31506 e a BAT_LOW event is signaled from the
\par \hich\af31506\dbch\af31505\loch\f31506  332  *  radio transceiver. This way it is possible for the end user to poll the flag
\par \hich\af31506\dbch\af31505\loch\f31506  333  *  for new event occurances.
\par \hich\af31506\dbch\af31505\loch\f31506  334  */
\par \hich\af31506\dbch\af31505\loch\f31506  335 //uint8_t
\par \hich\af31506\dbch\af31505\loch\f31506  336 //hal_get_bat_low_flag(void)
\par \hich\af31506\dbch\af31505\loch\f31506  337 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  338 //    return hal_bat_low_flag;
\par \hich\af31506\dbch\af31505\loch\f31506  339 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  340 
\par \hich\af31506\dbch\af31505\loch\f31506  341 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  342 /** \\brief  This function clears the BAT_LOW flag.
\par \hich\af31506\dbch\af31505\loch\f31506  343  */
\par \hich\af31506\dbch\af31505\loch\f31506  344 //void
\par \hich\af31506\dbch\af31505\loch\f31506  345 //hal_clear_bat_low_flag(void)
\par \hich\af31506\dbch\af31505\loch\f31506  346 /\hich\af31506\dbch\af31505\loch\f31506 /\{
\par \hich\af31506\dbch\af31505\loch\f31506  347 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  348 //    hal_bat_low_flag = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  349 //    HAL_LEAVE_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  350 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  351 
\par \hich\af31506\dbch\af31505\loch\f31506  352 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  353 /** \\brief  This function is used \hich\af31506\dbch\af31505\loch\f31506 to set new TRX_END event handler, overriding
\par \hich\af31506\dbch\af31505\loch\f31506  354  *          old handler reference.
\par \hich\af31506\dbch\af31505\loch\f31506  355  */
\par \hich\af31506\dbch\af31505\loch\f31506  356 //hal_trx_end_isr_event_handler_t
\par \hich\af31506\dbch\af31505\loch\f31506  357 //hal_get_trx_end_event_handler(void)
\par \hich\af31506\dbch\af31505\loch\f31506  358 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  359 //    return trx_end_callback;
\par \hich\af31506\dbch\af31505\loch\f31506  360 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  361 
\par \hich\af31506\dbch\af31505\loch\f31506  362 /*-------------\hich\af31506\dbch\af31505\loch\f31506 ---------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  363 /** \\brief  This function is used to set new TRX_END event handler, overriding
\par \hich\af31506\dbch\af31505\loch\f31506  364  *          old handler reference.
\par \hich\af31506\dbch\af31505\loch\f31506  365  */
\par \hich\af31506\dbch\af31505\loch\f31506  366 //void
\par \hich\af31506\dbch\af31505\loch\f31506  367 //hal_set_trx_end_event_handler(hal_trx_end_isr_event_handler_t trx_end_callback_handle)
\par \hich\af31506\dbch\af31505\loch\f31506  368 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  369 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  370 //    trx_end_callback = trx_end_callback_handle;
\par \hich\af31506\dbch\af31505\loch\f31506  371 //    HAL_LEAVE_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  372 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  373 
\par \hich\af31506\dbch\af31505\loch\f31506  37\hich\af31506\dbch\af31505\loch\f31506 4 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  375 /** \\brief  Remove event handler reference.
\par \hich\af31506\dbch\af31505\loch\f31506  376  */
\par \hich\af31506\dbch\af31505\loch\f31506  377 //void
\par \hich\af31506\dbch\af31505\loch\f31506  378 //hal_clear_trx_end_event_handler(void)
\par \hich\af31506\dbch\af31505\loch\f31506  379 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  380 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  381 //  \hich\af31506\dbch\af31505\loch\f31506   trx_end_callback = NULL;
\par \hich\af31506\dbch\af31505\loch\f31506  382 //    HAL_LEAVE_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  383 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  384 
\par \hich\af31506\dbch\af31505\loch\f31506  385 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  386 /** \\brief  This function returns the active RX_START event handler
\par \hich\af31506\dbch\af31505\loch\f31506  387  *
\par \hich\af31506\dbch\af31505\loch\f31506  388  *\hich\af31506\dbch\af31505\loch\f31506   \\return Current RX_START event handler registered.
\par \hich\af31506\dbch\af31505\loch\f31506  389  */
\par \hich\af31506\dbch\af31505\loch\f31506  390 //hal_rx_start_isr_event_handler_t
\par \hich\af31506\dbch\af31505\loch\f31506  391 //hal_get_rx_start_event_handler(void)
\par \hich\af31506\dbch\af31505\loch\f31506  392 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  393 //    return rx_start_callback;
\par \hich\af31506\dbch\af31505\loch\f31506  394 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  395 
\par \hich\af31506\dbch\af31505\loch\f31506  396 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  397 /** \\brief  This function is used to set new RX_START event handler, overriding
\par \hich\af31506\dbch\af31505\loch\f31506  398  *          old handler reference.
\par \hich\af31506\dbch\af31505\loch\f31506  399  */
\par \hich\af31506\dbch\af31505\loch\f31506  400 //void
\par \hich\af31506\dbch\af31505\loch\f31506  401 //hal_set_rx_start_\hich\af31506\dbch\af31505\loch\f31506 event_handler(hal_rx_start_isr_event_handler_t rx_start_callback_handle)
\par \hich\af31506\dbch\af31505\loch\f31506  402 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  403 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  404 //    rx_start_callback = rx_start_callback_handle;
\par \hich\af31506\dbch\af31505\loch\f31506  405 //    HAL_LEAVE_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  406 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  407 
\par \hich\af31506\dbch\af31505\loch\f31506  408 /*---------------\hich\af31506\dbch\af31505\loch\f31506 -------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  409 /** \\brief  Remove event handler reference.
\par \hich\af31506\dbch\af31505\loch\f31506  410  */
\par \hich\af31506\dbch\af31505\loch\f31506  411 //void
\par \hich\af31506\dbch\af31505\loch\f31506  412 //hal_clear_rx_start_event_handler(void)
\par \hich\af31506\dbch\af31505\loch\f31506  413 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  414 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  415 //    rx_start_callbac\hich\af31506\dbch\af31505\loch\f31506 k = NULL;
\par \hich\af31506\dbch\af31505\loch\f31506  416 //    HAL_LEAVE_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  417 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  418 
\par \hich\af31506\dbch\af31505\loch\f31506  419 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  420 /** \\brief  This function returns the current value of the PLL_LOCK flag.
\par \hich\af31506\dbch\af31505\loch\f31506  421  *
\par \hich\af31506\dbch\af31505\loch\f31506  422  *  The PLL_LOCK flag is incremented each time a PLL_LOCK event is signaled from the
\par \hich\af31506\dbch\af31505\loch\f31506  423  *  radio transceiver. This way it is possible for the end user to poll the flag
\par \hich\af31506\dbch\af31505\loch\f31506  424  *  for new event occurances.
\par \hich\af31506\dbch\af31505\loch\f31506  425  */
\par \hich\af31506\dbch\af31505\loch\f31506  426 //uint8_t
\par \hich\af31506\dbch\af31505\loch\f31506  427 //hal_get_pll_lo\hich\af31506\dbch\af31505\loch\f31506 ck_flag(void)
\par \hich\af31506\dbch\af31505\loch\f31506  428 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  429 //    return hal_pll_lock_flag;
\par \hich\af31506\dbch\af31505\loch\f31506  430 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  431 
\par \hich\af31506\dbch\af31505\loch\f31506  432 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  433 /** \\brief  This function clears the PLL_LOCK flag.
\par \hich\af31506\dbch\af31505\loch\f31506  434  */
\par \hich\af31506\dbch\af31505\loch\f31506  435 //void
\par \hich\af31506\dbch\af31505\loch\f31506  436 //hal_clear_\hich\af31506\dbch\af31505\loch\f31506 pll_lock_flag(void)
\par \hich\af31506\dbch\af31505\loch\f31506  437 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  438 //    HAL_ENTER_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  439 //    hal_pll_lock_flag = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  440 //    HAL_LEAVE_CRITICAL_REGION();
\par \hich\af31506\dbch\af31505\loch\f31506  441 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  442 
\par \hich\af31506\dbch\af31505\loch\f31506  443 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  444 /* Hack for internal radio registers. hal_register_re\hich\af31506\dbch\af31505\loch\f31506 ad and hal_register_write are
\par \hich\af31506\dbch\af31505\loch\f31506  445    handled through defines, but the preprocesser can't parse a macro containing
\par \hich\af31506\dbch\af31505\loch\f31506  446    another #define with multiple arguments, e.g. using
\par \hich\af31506\dbch\af31505\loch\f31506  447    #define hal_subregister_read( address, mask, position ) (address&mask)>>p\hich\af31506\dbch\af31505\loch\f31506 osition
\par \hich\af31506\dbch\af31505\loch\f31506  448    #define SR_TRX_STATUS         TRX_STATUS, 0x1f, 0
\par \hich\af31506\dbch\af31505\loch\f31506  449    the following only sees 1 argument to the macro
\par \hich\af31506\dbch\af31505\loch\f31506  450    return hal_subregister_read(SR_TRX_STATUS);
\par \hich\af31506\dbch\af31505\loch\f31506  451    
\par \hich\af31506\dbch\af31505\loch\f31506  452    Possible fix is through two defines:
\par \hich\af31506\dbch\af31505\loch\f31506  453    #define x_hal_subregister_read(x) hal_subregister_read(x);
\par \hich\af31506\dbch\af31505\loch\f31506  454    #define hal_subregister_read( address, mask, position ) (address&mask)>>position
\par \hich\af31506\dbch\af31505\loch\f31506  455    but the subregister defines in atmega128rfa1_registermap.h are currently set up without
\par \hich\af31506\dbch\af31505\loch\f31506  456\hich\af31506\dbch\af31505\loch\f31506     the _SFR_MEM8 attribute, for use by hal_subregister_write.
\par \hich\af31506\dbch\af31505\loch\f31506  457    
\par \hich\af31506\dbch\af31505\loch\f31506  458  */
\par \hich\af31506\dbch\af31505\loch\f31506  459 uint8_t
\par \hich\af31506\dbch\af31505\loch\f31506  460 hal_subregister_read(uint16_t address, uint8_t mask, uint8_t position)
\par \hich\af31506\dbch\af31505\loch\f31506  461 \{
\par \hich\af31506\dbch\af31505\loch\f31506  462     return (_SFR_MEM8(address)&mask)>>position;
\par \hich\af31506\dbch\af31505\loch\f31506  463 \}
\par \hich\af31506\dbch\af31505\loch\f31506  464 void
\par \hich\af31506\dbch\af31505\loch\f31506  465 hal_\hich\af31506\dbch\af31505\loch\f31506 subregister_write(uint16_t address, uint8_t mask, uint8_t position,
\par \hich\af31506\dbch\af31505\loch\f31506  466                             uint8_t value)
\par \hich\af31506\dbch\af31505\loch\f31506  467 \{
\par \hich\af31506\dbch\af31505\loch\f31506  468  cli();
\par \hich\af31506\dbch\af31505\loch\f31506  469     uint8_t register_value = _SFR_MEM8(address);
\par \hich\af31506\dbch\af31505\loch\f31506  470     register_value &= ~mask;
\par \hich\af31506\dbch\af31505\loch\f31506  471     value <<= position;
\par \hich\af31506\dbch\af31505\loch\f31506  47\hich\af31506\dbch\af31505\loch\f31506 2     value &= mask;
\par \hich\af31506\dbch\af31505\loch\f31506  473     value |= register_value;
\par \hich\af31506\dbch\af31505\loch\f31506  474     _SFR_MEM8(address) = value;
\par \hich\af31506\dbch\af31505\loch\f31506  475  sei();
\par \hich\af31506\dbch\af31505\loch\f31506  476 \}
\par \hich\af31506\dbch\af31505\loch\f31506  477 
\par \hich\af31506\dbch\af31505\loch\f31506  478 #else /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  479 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  480 /** \\brief  This function reads data from one of the radio transceiver's registers.
\par \hich\af31506\dbch\af31505\loch\f31506  481  *
\par \hich\af31506\dbch\af31505\loch\f31506  482  *  \\param  address Register address to read from. See datasheet for register
\par \hich\af31506\dbch\af31505\loch\f31506  483  *                  map.
\par \hich\af31506\dbch\af31505\loch\f31506  484  *
\par \hich\af31506\dbch\af31505\loch\f31506  485  *  \\see Look at the at86rf230_re\hich\af31506\dbch\af31505\loch\f31506 gistermap.h file for register address definitions.
\par \hich\af31506\dbch\af31505\loch\f31506  486  *
\par \hich\af31506\dbch\af31505\loch\f31506  487  *  \\returns The actual value of the read register.
\par \hich\af31506\dbch\af31505\loch\f31506  488  */
\par \hich\af31506\dbch\af31505\loch\f31506  489 uint8_t
\par \hich\af31506\dbch\af31505\loch\f31506  490 hal_register_read(uint8_t address)
\par \hich\af31506\dbch\af31505\loch\f31506  491 \{
\par \hich\af31506\dbch\af31505\loch\f31506  492     uint8_t register_value;
\par \hich\af31506\dbch\af31505\loch\f31506  493     /* Add the register read comm\hich\af31506\dbch\af31505\loch\f31506 and to the register address. */
\par \hich\af31506\dbch\af31505\loch\f31506  494     /* Address should be < 0x2f so no need to mask */
\par \hich\af31506\dbch\af31505\loch\f31506  495 //  address &= 0x3f;
\par \hich\af31506\dbch\af31505\loch\f31506  496     address |= 0x80;
\par \hich\af31506\dbch\af31505\loch\f31506  497 
\par \hich\af31506\dbch\af31505\loch\f31506  498     HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  499 
\par \hich\af31506\dbch\af31505\loch\f31506  500     /*Send Register address and read register content.*/
\par \hich\af31506\dbch\af31505\loch\f31506  501 \hich\af31506\dbch\af31505\loch\f31506     HAL_SPI_TRANSFER(address);
\par \hich\af31506\dbch\af31505\loch\f31506  502     register_value = HAL_SPI_TRANSFER(0);
\par \hich\af31506\dbch\af31505\loch\f31506  503 
\par \hich\af31506\dbch\af31505\loch\f31506  504     HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  505 
\par \hich\af31506\dbch\af31505\loch\f31506  506     return register_value;
\par \hich\af31506\dbch\af31505\loch\f31506  507 \}
\par \hich\af31506\dbch\af31505\loch\f31506  508 
\par \hich\af31506\dbch\af31505\loch\f31506  509 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  510 /** \\brief  This function writes a new value to one of the radio transceiver's
\par \hich\af31506\dbch\af31505\loch\f31506  511  *          registers.
\par \hich\af31506\dbch\af31505\loch\f31506  512  *
\par \hich\af31506\dbch\af31505\loch\f31506  513  *  \\see Look at the at86rf230_registermap.h file for register address definitions.
\par \hich\af31506\dbch\af31505\loch\f31506  514  *
\par \hich\af31506\dbch\af31505\loch\f31506  515  *  \\param  address Address of reg\hich\af31506\dbch\af31505\loch\f31506 ister to write.
\par \hich\af31506\dbch\af31505\loch\f31506  516  *  \\param  value   Value to write.
\par \hich\af31506\dbch\af31505\loch\f31506  517  */
\par \hich\af31506\dbch\af31505\loch\f31506  518 void
\par \hich\af31506\dbch\af31505\loch\f31506  519 hal_register_write(uint8_t address, uint8_t value)
\par \hich\af31506\dbch\af31505\loch\f31506  520 \{
\par \hich\af31506\dbch\af31505\loch\f31506  521     /* Add the Register Write (short mode) command to the address. */
\par \hich\af31506\dbch\af31505\loch\f31506  522     address = 0xc0 | address;
\par \hich\af31506\dbch\af31505\loch\f31506  523 
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506 524     HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  525 
\par \hich\af31506\dbch\af31505\loch\f31506  526     /*Send Register address and write register content.*/
\par \hich\af31506\dbch\af31505\loch\f31506  527     HAL_SPI_TRANSFER(address);
\par \hich\af31506\dbch\af31505\loch\f31506  528     HAL_SPI_TRANSFER(value);
\par \hich\af31506\dbch\af31505\loch\f31506  529 
\par \hich\af31506\dbch\af31505\loch\f31506  530     HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  531 \}
\par \hich\af31506\dbch\af31505\loch\f31506  532 /*-----------------------------\hich\af31506\dbch\af31505\loch\f31506 -----------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  533 /** \\brief  This function reads the value of a specific subregister.
\par \hich\af31506\dbch\af31505\loch\f31506  534  *
\par \hich\af31506\dbch\af31505\loch\f31506  535  *  \\see Look at the at86rf230_registermap.h file for register and subregister
\par \hich\af31506\dbch\af31505\loch\f31506  536  *       definitions.
\par \hich\af31506\dbch\af31505\loch\f31506  537  *
\par \hich\af31506\dbch\af31505\loch\f31506  538  *  \\param  address  Main register's address.
\par \hich\af31506\dbch\af31505\loch\f31506  539  *  \\param  mask  Bit mask of the subregister.
\par \hich\af31506\dbch\af31505\loch\f31506  540  *  \\param  position   Bit position of the subregister
\par \hich\af31506\dbch\af31505\loch\f31506  541  *  \\retval Value of the read subregister.
\par \hich\af31506\dbch\af31505\loch\f31506  542  */
\par \hich\af31506\dbch\af31505\loch\f31506  543 uint8_t
\par \hich\af31506\dbch\af31505\loch\f31506  544 hal_subregister_re\hich\af31506\dbch\af31505\loch\f31506 ad(uint8_t address, uint8_t mask, uint8_t position)
\par \hich\af31506\dbch\af31505\loch\f31506  545 \{
\par \hich\af31506\dbch\af31505\loch\f31506  546     /* Read current register value and mask out subregister. */
\par \hich\af31506\dbch\af31505\loch\f31506  547     uint8_t register_value = hal_register_read(address);
\par \hich\af31506\dbch\af31505\loch\f31506  548     register_value &= mask;
\par \hich\af31506\dbch\af31505\loch\f31506  549     register_value >>= posit\hich\af31506\dbch\af31505\loch\f31506 ion; /* Align subregister value. */
\par \hich\af31506\dbch\af31505\loch\f31506  550 
\par \hich\af31506\dbch\af31505\loch\f31506  551     return register_value;
\par \hich\af31506\dbch\af31505\loch\f31506  552 \}
\par \hich\af31506\dbch\af31505\loch\f31506  553 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  554 /** \\brief  This function writes a new value to one of the radio transceiver's
\par \hich\af31506\dbch\af31505\loch\f31506  555 \hich\af31506\dbch\af31505\loch\f31506  *          subregisters.
\par \hich\af31506\dbch\af31505\loch\f31506  556  *
\par \hich\af31506\dbch\af31505\loch\f31506  557  *  \\see Look at the at86rf230_registermap.h file for register and subregister
\par \hich\af31506\dbch\af31505\loch\f31506  558  *       definitions.
\par \hich\af31506\dbch\af31505\loch\f31506  559  *
\par \hich\af31506\dbch\af31505\loch\f31506  560  *  \\param  address  Main register's address.
\par \hich\af31506\dbch\af31505\loch\f31506  561  *  \\param  mask  Bit mask of the subregister.
\par \hich\af31506\dbch\af31505\loch\f31506  562  *  \\param  position  Bit position of the subregister
\par \hich\af31506\dbch\af31505\loch\f31506  563  *  \\param  value  Value to write into the subregister.
\par \hich\af31506\dbch\af31505\loch\f31506  564  */
\par \hich\af31506\dbch\af31505\loch\f31506  565 void
\par \hich\af31506\dbch\af31505\loch\f31506  566 hal_subregister_write(uint8_t address, uint8_t mask, uint8_t position,
\par \hich\af31506\dbch\af31505\loch\f31506  567                             uint8_t \hich\af31506\dbch\af31505\loch\f31506 value)
\par \hich\af31506\dbch\af31505\loch\f31506  568 \{
\par \hich\af31506\dbch\af31505\loch\f31506  569     /* Read current register value and mask area outside the subregister. */
\par \hich\af31506\dbch\af31505\loch\f31506  570     volatile uint8_t register_value = hal_register_read(address);
\par \hich\af31506\dbch\af31505\loch\f31506  571     register_value &= ~mask;
\par \hich\af31506\dbch\af31505\loch\f31506  572 
\par \hich\af31506\dbch\af31505\loch\f31506  573     /* Start preparing the new subregister v\hich\af31506\dbch\af31505\loch\f31506 alue. shift in place and mask. */
\par \hich\af31506\dbch\af31505\loch\f31506  574     value <<= position;
\par \hich\af31506\dbch\af31505\loch\f31506  575     value &= mask;
\par \hich\af31506\dbch\af31505\loch\f31506  576 
\par \hich\af31506\dbch\af31505\loch\f31506  577     value |= register_value; /* Set the new subregister value. }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 */
\par \hich\af31506\dbch\af31505\loch\f31506  578 
\par \hich\af31506\dbch\af31505\loch\f31506  579     /* Write the modified register value. */
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 580     hal_register_write(address,\hich\af31506\dbch\af31505\loch\f31506 
 value);
\par \hich\af31506\dbch\af31505\loch\f31506  581 \}
\par \hich\af31506\dbch\af31505\loch\f31506  582 #endif /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  583 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  584 /** \\brief  Transfer a frame from the radio transceiver to a RAM buffer
\par \hich\af31506\dbch\af31505\loch\f31506  585  *
\par \hich\af31506\dbch\af31505\loch\f31506  586  *          Thi\hich\af31506\dbch\af31505\loch\f31506 s version is optimized for use with contiki RF230BB driver.
\par \hich\af31506\dbch\af31505\loch\f31506  587  *          The callback routine and CRC are left out for speed in reading the rx buffer.
\par \hich\af31506\dbch\af31505\loch\f31506  588  *          Any delays here can lead to overwrites by the next packet!
\par \hich\af31506\dbch\af31505\loch\f31506  589  *
\par \hich\af31506\dbch\af31505\loch\f31506  590  *          If the frame length is out of the defined bounds, the length, lqi and crc
\par \hich\af31506\dbch\af31505\loch\f31506  591  *          are set to zero.
\par \hich\af31506\dbch\af31505\loch\f31506  592  *
\par \hich\af31506\dbch\af31505\loch\f31506  593  *  \\param  rx_frame    Pointer to the data structure where the frame is stored.
\par \hich\af31506\dbch\af31505\loch\f31506  594  */
\par \hich\af31506\dbch\af31505\loch\f31506  595 void
\par \hich\af31506\dbch\af31505\loch\f31506  596 hal_frame_rea\hich\af31506\dbch\af31505\loch\f31506 d(hal_rx_frame_t *rx_frame)
\par \hich\af31506\dbch\af31505\loch\f31506  597 \{
\par \hich\af31506\dbch\af31505\loch\f31506  598 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  599 
\par \hich\af31506\dbch\af31505\loch\f31506  600     uint8_t frame_length,*rx_data,*rx_buffer;
\par \hich\af31506\dbch\af31505\loch\f31506  601  
\par \hich\af31506\dbch\af31505\loch\f31506  602     /* Get length from the TXT_RX_LENGTH register, not including LQI
\par \hich\af31506\dbch\af31505\loch\f31506  603      * Bypassing the length check can \hich\af31506\dbch\af31505\loch\f31506 result in overrun if buffer is < 256 bytes.
\par \hich\af31506\dbch\af31505\loch\f31506  604      */
\par \hich\af31506\dbch\af31505\loch\f31506  605     frame_length = TST_RX_LENGTH;
\par \hich\af31506\dbch\af31505\loch\f31506  606     if ( 0 || ((frame_length >= HAL_MIN_FRAME_LENGTH) && (frame_length <= HAL_MAX_FRAME_LENGTH))) \{
\par \hich\af31506\dbch\af31505\loch\f31506  607         rx_frame->length = frame_length;
\par \hich\af31506\dbch\af31505\loch\f31506  608 
\par \hich\af31506\dbch\af31505\loch\f31506  60\hich\af31506\dbch\af31505\loch\f31506 9         /* Start of buffer in I/O space, pointer to RAM buffer */
\par \hich\af31506\dbch\af31505\loch\f31506  610         rx_buffer=(uint8_t *)0x180;
\par \hich\af31506\dbch\af31505\loch\f31506  611         rx_data = (rx_frame->data);
\par \hich\af31506\dbch\af31505\loch\f31506  612 
\par \hich\af31506\dbch\af31505\loch\f31506  613         do\{
\par \hich\af31506\dbch\af31505\loch\f31506  614             *rx_data++ = _SFR_MEM8(rx_buffer++);
\par \hich\af31506\dbch\af31505\loch\f31506  615         \} while (--frame\hich\af31506\dbch\af31505\loch\f31506 _length > 0);
\par \hich\af31506\dbch\af31505\loch\f31506  616 
\par \hich\af31506\dbch\af31505\loch\f31506  617         /*Read LQI value for this frame.*/
\par \hich\af31506\dbch\af31505\loch\f31506  618         rx_frame->lqi = *rx_buffer;
\par \hich\af31506\dbch\af31505\loch\f31506  619     
\par \hich\af31506\dbch\af31505\loch\f31506  620 #else /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  621 
\par \hich\af31506\dbch\af31505\loch\f31506  622     uint8_t *rx_data;
\par \hich\af31506\dbch\af31505\loch\f31506  623 
\par \hich\af31506\dbch\af31505\loch\f31506  624     /*Send frame read (long mode) command.*/
\par \hich\af31506\dbch\af31505\loch\f31506  625     HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  626     HAL_SPI_TRANSFER(0x20);
\par \hich\af31506\dbch\af31505\loch\f31506  627 
\par \hich\af31506\dbch\af31505\loch\f31506  628     /*Read frame length. This includes the checksum. */
\par \hich\af31506\dbch\af31505\loch\f31506  629     uint8_t frame_length = HAL_SPI_TRANSFER(0);
\par \hich\af31506\dbch\af31505\loch\f31506  630 
\par \hich\af31506\dbch\af31505\loch\f31506  631     /*Check for correct frame length. Bypassing this test \hich\af31506\dbch\af31505\loch\f31506 can result in a buffer overrun! */
\par \hich\af31506\dbch\af31505\loch\f31506  632     if ( 0 || ((frame_length >= HAL_MIN_FRAME_LENGTH) && (frame_length <= HAL_MAX_FRAME_LENGTH))) \{
\par \hich\af31506\dbch\af31505\loch\f31506  633 
\par \hich\af31506\dbch\af31505\loch\f31506  634         rx_data = (rx_frame->data);
\par \hich\af31506\dbch\af31505\loch\f31506  635         rx_frame->length = frame_length;
\par \hich\af31506\dbch\af31505\loch\f31506  636 
\par \hich\af31506\dbch\af31505\loch\f31506  637         /*Tr\hich\af31506\dbch\af31505\loch\f31506 ansfer frame buffer to RAM buffer */
\par \hich\af31506\dbch\af31505\loch\f31506  638 
\par \hich\af31506\dbch\af31505\loch\f31506  639             HAL_SPI_TRANSFER_WRITE(0);
\par \hich\af31506\dbch\af31505\loch\f31506  640             HAL_SPI_TRANSFER_WAIT();
\par \hich\af31506\dbch\af31505\loch\f31506  641         do\{
\par \hich\af31506\dbch\af31505\loch\f31506  642             *rx_data++ = HAL_SPI_TRANSFER_READ();
\par \hich\af31506\dbch\af31505\loch\f31506  643             HAL_SPI_TRANSFER_WRITE(0);
\par \hich\af31506\dbch\af31505\loch\f31506  644 
\par \hich\af31506\dbch\af31505\loch\f31506  645 \hich\af31506\dbch\af31505\loch\f31506             /* CRC was checked in hardware, but redoing the checksum here ensures the rx buffer
\par \hich\af31506\dbch\af31505\loch\f31506  646              * is not being overwritten by the next packet. Since that lengthy computation makes
\par \hich\af31506\dbch\af31505\loch\f31506  647              * such overwrites more likely, we skip it and hope for the best.
\par \hich\af31506\dbch\af31505\loch\f31506  648              * Without the check a full buffer is read in 320us at 2x spi clocking.
\par \hich\af31506\dbch\af31505\loch\f31506  649              * The 802.15.4 standard requires 640us after a greater than 18 byt\hich\af31506\dbch\af31505\loch\f31506 e frame.
\par \hich\af31506\dbch\af31505\loch\f31506  650              * With a low interrupt latency overwrites should never occur.
\par \hich\af31506\dbch\af31505\loch\f31506  651              */
\par \hich\af31506\dbch\af31505\loch\f31506  652 //          crc = _crc_ccitt_update(crc, tempData);
\par \hich\af31506\dbch\af31505\loch\f31506  653 
\par \hich\af31506\dbch\af31505\loch\f31506  654             HAL_SPI_TRANSFER_WAIT();
\par \hich\af31506\dbch\af31505\loch\f31506  655 
\par \hich\af31506\dbch\af31505\loch\f31506  656         \} while (--frame_lengt\hich\af31506\dbch\af31505\loch\f31506 h > 0);
\par \hich\af31506\dbch\af31505\loch\f31506  657 
\par \hich\af31506\dbch\af31505\loch\f31506  658 
\par \hich\af31506\dbch\af31505\loch\f31506  659         /*Read LQI value for this frame.*/
\par \hich\af31506\dbch\af31505\loch\f31506  660             rx_frame->lqi = HAL_SPI_TRANSFER_READ();
\par \hich\af31506\dbch\af31505\loch\f31506  661         
\par \hich\af31506\dbch\af31505\loch\f31506  662 #endif /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  663 
\par \hich\af31506\dbch\af31505\loch\f31506  664         /* If crc was calculated set crc field in hal_rx\hich\af31506\dbch\af31505\loch\f31506 _frame_t accordingly.
\par \hich\af31506\dbch\af31505\loch\f31506  665          * Else show the crc has passed the hardware check.
\par \hich\af31506\dbch\af31505\loch\f31506  666          */
\par \hich\af31506\dbch\af31505\loch\f31506  667         rx_frame->crc   = true;
\par \hich\af31506\dbch\af31505\loch\f31506  668 
\par \hich\af31506\dbch\af31505\loch\f31506  669     \} else \{
\par \hich\af31506\dbch\af31505\loch\f31506  670         /* Length test failed */
\par \hich\af31506\dbch\af31505\loch\f31506  671         rx_frame->length = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  672         rx_fr\hich\af31506\dbch\af31505\loch\f31506 ame->lqi    = 0;
\par \hich\af31506\dbch\af31505\loch\f31506  673         rx_frame->crc    = false;
\par \hich\af31506\dbch\af31505\loch\f31506  674     \}
\par \hich\af31506\dbch\af31505\loch\f31506  675 
\par \hich\af31506\dbch\af31505\loch\f31506  676     HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  677 \}
\par \hich\af31506\dbch\af31505\loch\f31506  678 
\par \hich\af31506\dbch\af31505\loch\f31506  679 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  680 /** \\\hich\af31506\dbch\af31505\loch\f31506 brief  This function will download a frame to the radio transceiver's frame
\par \hich\af31506\dbch\af31505\loch\f31506  681  *          buffer.
\par \hich\af31506\dbch\af31505\loch\f31506  682  *
\par \hich\af31506\dbch\af31505\loch\f31506  683  *  \\param  write_buffer    Pointer to data that is to be written to frame buffer.
\par \hich\af31506\dbch\af31505\loch\f31506  684  *  \\param  length          Length of data. The maximu\hich\af31506\dbch\af31505\loch\f31506 m length is 127 bytes.
\par \hich\af31506\dbch\af31505\loch\f31506  685  */
\par \hich\af31506\dbch\af31505\loch\f31506  686 void
\par \hich\af31506\dbch\af31505\loch\f31506  687 hal_frame_write(uint8_t *write_buffer, uint8_t length)
\par \hich\af31506\dbch\af31505\loch\f31506  688 \{
\par \hich\af31506\dbch\af31505\loch\f31506  689 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  690     uint8_t *tx_buffer;
\par \hich\af31506\dbch\af31505\loch\f31506  691     tx_buffer=(uint8_t *)0x180;  //start of fifo in i/o space
\par \hich\af31506\dbch\af31505\loch\f31506  692     /*\hich\af31506\dbch\af31505\loch\f31506  Write frame length, including the two byte checksum */
\par \hich\af31506\dbch\af31505\loch\f31506  693     /* The top bit of the length field shall be set to 0 for IEEE 802.15.4 compliant frames */
\par \hich\af31506\dbch\af31505\loch\f31506  694     /* It should already be clear, so bypassing the masking is sanity check of the uip stack */
\par \hich\af31506\dbch\af31505\loch\f31506  695 //  length &= 0x7f;
\par \hich\af31506\dbch\af31505\loch\f31506  696     _SFR_MEM8(tx_buffer++) = length;
\par \hich\af31506\dbch\af31505\loch\f31506  697     
\par \hich\af31506\dbch\af31505\loch\f31506  698     /* Download to the Frame Buffer.
\par \hich\af31506\dbch\af31505\loch\f31506  699      * When the FCS is autogenerated there is no need to transfer the last two bytes
\par \hich\af31506\dbch\af31505\loch\f31506  700      * since they will be overwritten.
\par \hich\af31506\dbch\af31505\loch\f31506  7\hich\af31506\dbch\af31505\loch\f31506 01      */
\par \hich\af31506\dbch\af31505\loch\f31506  702 #if !RF230_CONF_CHECKSUM
\par \hich\af31506\dbch\af31505\loch\f31506  703     length -= 2;
\par \hich\af31506\dbch\af31505\loch\f31506  704 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  705     do  _SFR_MEM8(tx_buffer++)= *write_buffer++; while (--length);
\par \hich\af31506\dbch\af31505\loch\f31506  706 
\par \hich\af31506\dbch\af31505\loch\f31506  707 #else /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  708     /* Optionally truncate length to maxi\hich\af31506\dbch\af31505\loch\f31506 mum frame length.
\par \hich\af31506\dbch\af31505\loch\f31506  709      * Not doing this is a fast way to know when the application needs fixing!
\par \hich\af31506\dbch\af31505\loch\f31506  710      */
\par \hich\af31506\dbch\af31505\loch\f31506  711 //  length &= 0x7f; 
\par \hich\af31506\dbch\af31505\loch\f31506  712 
\par \hich\af31506\dbch\af31505\loch\f31506  713     HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  714 
\par \hich\af31506\dbch\af31505\loch\f31506  715     /* Send Frame Transmit (long mode) command and frame length \hich\af31506\dbch\af31505\loch\f31506 */
\par \hich\af31506\dbch\af31505\loch\f31506  716     HAL_SPI_TRANSFER(0x60);
\par \hich\af31506\dbch\af31505\loch\f31506  717     HAL_SPI_TRANSFER(length);
\par \hich\af31506\dbch\af31505\loch\f31506  718 
\par \hich\af31506\dbch\af31505\loch\f31506  719     /* Download to the Frame Buffer.
\par \hich\af31506\dbch\af31505\loch\f31506  720      * When the FCS is autogenerated there is no need to transfer the last two bytes
\par \hich\af31506\dbch\af31505\loch\f31506  721      * since they will be overwritten.
\par \hich\af31506\dbch\af31505\loch\f31506  72\hich\af31506\dbch\af31505\loch\f31506 2      */
\par \hich\af31506\dbch\af31505\loch\f31506  723 #if !RF230_CONF_CHECKSUM
\par \hich\af31506\dbch\af31505\loch\f31506  724     length -= 2;
\par \hich\af31506\dbch\af31505\loch\f31506  725 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  726     do HAL_SPI_TRANSFER(*write_buffer++); while (--length);
\par \hich\af31506\dbch\af31505\loch\f31506  727 
\par \hich\af31506\dbch\af31505\loch\f31506  728     HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  729 #endif /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  730 \}
\par \hich\af31506\dbch\af31505\loch\f31506  731 
\par \hich\af31506\dbch\af31505\loch\f31506  732 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  733 /** \\brief Read SRAM
\par \hich\af31506\dbch\af31505\loch\f31506  734  *
\par \hich\af31506\dbch\af31505\loch\f31506  735  * This function reads from the SRAM of the radio transceiver.
\par \hich\af31506\dbch\af31505\loch\f31506  736  *
\par \hich\af31506\dbch\af31505\loch\f31506  737  * \\param address Address in the TRX's SRAM where the r\hich\af31506\dbch\af31505\loch\f31506 ead burst should start
\par \hich\af31506\dbch\af31505\loch\f31506  738  * \\param length Length of the read burst
\par \hich\af31506\dbch\af31505\loch\f31506  739  * \\param data Pointer to buffer where data is stored.
\par \hich\af31506\dbch\af31505\loch\f31506  740  */
\par \hich\af31506\dbch\af31505\loch\f31506  741 #if 0  //Uses 80 bytes (on Raven) omit unless needed
\par \hich\af31506\dbch\af31505\loch\f31506  742 void
\par \hich\af31506\dbch\af31505\loch\f31506  743 hal_sram_read(uint8_t address, uint8_t lengt\hich\af31506\dbch\af31505\loch\f31506 h, uint8_t *data)
\par \hich\af31506\dbch\af31505\loch\f31506  744 \{
\par \hich\af31506\dbch\af31505\loch\f31506  745     HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  746 
\par \hich\af31506\dbch\af31505\loch\f31506  747     /*Send SRAM read command and address to start*/
\par \hich\af31506\dbch\af31505\loch\f31506  748     HAL_SPI_TRANSFER(0x00);
\par \hich\af31506\dbch\af31505\loch\f31506  749     HAL_SPI_TRANSFER(address);
\par \hich\af31506\dbch\af31505\loch\f31506  750 
\par \hich\af31506\dbch\af31505\loch\f31506  751     HAL_SPI_TRANSFER_WRITE(0);
\par \hich\af31506\dbch\af31505\loch\f31506  752     HAL_SPI_TRANSF\hich\af31506\dbch\af31505\loch\f31506 ER_WAIT();
\par \hich\af31506\dbch\af31505\loch\f31506  753 
\par \hich\af31506\dbch\af31505\loch\f31506  754     /*Upload the chosen memory area.*/
\par \hich\af31506\dbch\af31505\loch\f31506  755     do\{
\par \hich\af31506\dbch\af31505\loch\f31506  756         *data++ = HAL_SPI_TRANSFER_READ();
\par \hich\af31506\dbch\af31505\loch\f31506  757         HAL_SPI_TRANSFER_WRITE(0);
\par \hich\af31506\dbch\af31505\loch\f31506  758         HAL_SPI_TRANSFER_WAIT();
\par \hich\af31506\dbch\af31505\loch\f31506  759     \} while (--length > 0);
\par \hich\af31506\dbch\af31505\loch\f31506  760 
\par \hich\af31506\dbch\af31505\loch\f31506  761     HAL_S\hich\af31506\dbch\af31505\loch\f31506 PI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  762 \}
\par \hich\af31506\dbch\af31505\loch\f31506  763 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  764 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  765 /** \\brief Write SRAM
\par \hich\af31506\dbch\af31505\loch\f31506  766  *
\par \hich\af31506\dbch\af31505\loch\f31506  767  * This function writes into the SRAM of the radio transceiver. It can reduce
\par \hich\af31506\dbch\af31505\loch\f31506  768  * SPI \hich\af31506\dbch\af31505\loch\f31506 transfers if only part of a frame is to be changed before retransmission.
\par \hich\af31506\dbch\af31505\loch\f31506  769  *
\par \hich\af31506\dbch\af31505\loch\f31506  770  * \\param address Address in the TRX's SRAM where the write burst should start
\par \hich\af31506\dbch\af31505\loch\f31506  771  * \\param length  Length of the write burst
\par \hich\af31506\dbch\af31505\loch\f31506  772  * \\param data    Pointer to an arra\hich\af31506\dbch\af31505\loch\f31506 y of bytes that should be written
\par \hich\af31506\dbch\af31505\loch\f31506  773  */
\par \hich\af31506\dbch\af31505\loch\f31506  774 //void
\par \hich\af31506\dbch\af31505\loch\f31506  775 //hal_sram_write(uint8_t address, uint8_t length, uint8_t *data)
\par \hich\af31506\dbch\af31505\loch\f31506  776 //\{
\par \hich\af31506\dbch\af31505\loch\f31506  777 //    HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  778 
\par \hich\af31506\dbch\af31505\loch\f31506  779     /*Send SRAM write command.*/
\par \hich\af31506\dbch\af31505\loch\f31506  780 //    HAL_SPI_TRANSFER(0x40);
\par \hich\af31506\dbch\af31505\loch\f31506  781 
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506 782     /*Send address where to start writing to.*/
\par \hich\af31506\dbch\af31505\loch\f31506  783 //    HAL_SPI_TRANSFER(address);
\par \hich\af31506\dbch\af31505\loch\f31506  784 
\par \hich\af31506\dbch\af31505\loch\f31506  785     /*Upload the chosen memory area.*/
\par \hich\af31506\dbch\af31505\loch\f31506  786 //    do\{
\par \hich\af31506\dbch\af31505\loch\f31506  787 //        HAL_SPI_TRANSFER(*data++);
\par \hich\af31506\dbch\af31505\loch\f31506  788 //    \} while (--length > 0);
\par \hich\af31506\dbch\af31505\loch\f31506  789 
\par \hich\af31506\dbch\af31505\loch\f31506  790 //    HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  791 
\par \hich\af31506\dbch\af31505\loch\f31506  792 //\}
\par \hich\af31506\dbch\af31505\loch\f31506  793 
\par \hich\af31506\dbch\af31505\loch\f31506  794 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506  795 /* This #if compile switch is used to provide a "standard" function body for the */
\par \hich\af31506\dbch\af31505\loch\f31506  796 /* doxygen documen\hich\af31506\dbch\af31505\loch\f31506 tation. */
\par \hich\af31506\dbch\af31505\loch\f31506  797 #if defined(DOXYGEN)
\par \hich\af31506\dbch\af31505\loch\f31506  798 /** \\brief ISR for the radio IRQ line, triggered by the input capture.
\par \hich\af31506\dbch\af31505\loch\f31506  799  *  This is the interrupt service routine for timer1.ICIE1 input capture.
\par \hich\af31506\dbch\af31505\loch\f31506  800  *  It is triggered of a rising edge on the radio transceiv\hich\af31506\dbch\af31505\loch\f31506 ers IRQ line.
\par \hich\af31506\dbch\af31505\loch\f31506  801  */
\par \hich\af31506\dbch\af31505\loch\f31506  802 void RADIO_VECT(void);
\par \hich\af31506\dbch\af31505\loch\f31506  803 #else  /* !DOXYGEN */
\par \hich\af31506\dbch\af31505\loch\f31506  804 /* These link to the RF230BB driver in rf230.c */
\par \hich\af31506\dbch\af31505\loch\f31506  805 void rf230_interrupt(void);
\par \hich\af31506\dbch\af31505\loch\f31506  806 
\par \hich\af31506\dbch\af31505\loch\f31506  807 extern hal_rx_frame_t rxframe[RF230_CONF_RX_BUFFERS];
\par \hich\af31506\dbch\af31505\loch\f31506  808 extern uint8_t rxfra\hich\af31506\dbch\af31505\loch\f31506 me_head,rxframe_tail;
\par \hich\af31506\dbch\af31505\loch\f31506  809 
\par \hich\af31506\dbch\af31505\loch\f31506  810 #if defined(__AVR_ATmega128RFA1__)
\par \hich\af31506\dbch\af31505\loch\f31506  811 /* The atmega128rfa1 has individual interrupts for the integrated radio'
\par \hich\af31506\dbch\af31505\loch\f31506  812  * Whichever are enabled by the RF230 driver must be present even if not used!
\par \hich\af31506\dbch\af31505\loch\f31506  813  */
\par \hich\af31506\dbch\af31505\loch\f31506  814 /* Received packet interrupt */
\par \hich\af31506\dbch\af31505\loch\f31506  815 ISR(TRX24_RX_END_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  816 \{
\par \hich\af31506\dbch\af31505\loch\f31506  817 /* Get the rssi from ED if extended mode */
\par \hich\af31506\dbch\af31505\loch\f31506  818 #if RF230_CONF_AUTOACK
\par \hich\af31506\dbch\af31505\loch\f31506  819         rf230_last_rssi=hal_register_read(RG_PHY_ED_LEVEL);
\par \hich\af31506\dbch\af31505\loch\f31506  820 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  821 
\par \hich\af31506\dbch\af31505\loch\f31506  822 /* Buffer the frame\hich\af31506\dbch\af31505\loch\f31506  and call rf230_interrupt to schedule poll for rf230 receive process */
\par \hich\af31506\dbch\af31505\loch\f31506  823 /* Is a ram buffer available? */
\par \hich\af31506\dbch\af31505\loch\f31506  824         if (rxframe[rxframe_tail].length) \{DEBUGFLOW('0');\} else /*DEBUGFLOW('1')*/;
\par \hich\af31506\dbch\af31505\loch\f31506  825 
\par \hich\af31506\dbch\af31505\loch\f31506  826 #ifdef RF230_MIN_RX_POWER                
\par \hich\af31506\dbch\af31505\loch\f31506  82\hich\af31506\dbch\af31505\loch\f31506 7 /* Discard packets weaker than the minimum if defined. This is for testing miniature meshes */
\par \hich\af31506\dbch\af31505\loch\f31506  828 /* This does not prevent an autoack. TODO:rfa1 radio can be set up to not autoack weak packets */
\par \hich\af31506\dbch\af31505\loch\f31506  829         if (rf230_last_rssi >= RF230_MIN_RX_POWER) \{
\par \hich\af31506\dbch\af31505\loch\f31506  830 #else
\par \hich\af31506\dbch\af31505\loch\f31506  831         if (1) \{
\par \hich\af31506\dbch\af31505\loch\f31506  832 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  833 //              DEBUGFLOW('2');
\par \hich\af31506\dbch\af31505\loch\f31506  834                 hal_frame_read(&rxframe[rxframe_tail]);
\par \hich\af31506\dbch\af31505\loch\f31506  835                 rxframe_tail++;if (rxframe_tail >= RF230_CONF_RX_BUFFERS) rxframe_tail=0;
\par \hich\af31506\dbch\af31505\loch\f31506  836            \hich\af31506\dbch\af31505\loch\f31506      rf230_interrupt();
\par \hich\af31506\dbch\af31505\loch\f31506  837         \}
\par \hich\af31506\dbch\af31505\loch\f31506  838 \}
\par \hich\af31506\dbch\af31505\loch\f31506  839 /* Preamble detected, starting frame reception */
\par \hich\af31506\dbch\af31505\loch\f31506  840 ISR(TRX24_RX_START_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  841 \{
\par \hich\af31506\dbch\af31505\loch\f31506  842 //      DEBUGFLOW('3');
\par \hich\af31506\dbch\af31505\loch\f31506  843 /* Save RSSI for this packet if not in extended mode, scaling to 1dB resolution */
\par \hich\af31506\dbch\af31505\loch\f31506  844 #if !RF230_CONF_AUTOACK
\par \hich\af31506\dbch\af31505\loch\f31506  845     rf230_last_rssi = 3 * hal_subregister_read(SR_RSSI);
\par \hich\af31506\dbch\af31505\loch\f31506  846 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  847 
\par \hich\af31506\dbch\af31505\loch\f31506  848 \}
\par \hich\af31506\dbch\af31505\loch\f31506  849 
\par \hich\af31506\dbch\af31505\loch\f31506  850 /* PLL has locked, either from a transition out of TRX_OFF or a channel change while on */
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 851 ISR(TRX24_PLL_LOCK_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 852 \{
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506 853 //      DEBUGFLOW('4');
\par \hich\af31506\dbch\af31505\loch\f31506  854 \}
\par \hich\af31506\dbch\af31505\loch\f31506  855 
\par \hich\af31506\dbch\af31505\loch\f31506  856 /* PLL has unexpectedly unlocked */
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 857 ISR(TRX24_PLL_UNLOCK_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 858 \{
\par \hich\af31506\dbch\af31505\loch\f31506  859         DEBUGFLOW('5');
\par \hich\af31506\dbch\af31505\loch\f31506  860 \}
\par \hich\af31506\dbch\af31505\loch\f31506  861 /* Flag is set by the following interrupts */
\par \hich\af31506\dbch\af31505\loch\f31506  862 extern volatile uint8_t rf230_interruptwait\hich\af31506\dbch\af31505\loch\f31506 ,rf230_ccawait;
\par \hich\af31506\dbch\af31505\loch\f31506  863 
\par \hich\af31506\dbch\af31505\loch\f31506  864 /* Wake has finished */
\par \hich\af31506\dbch\af31505\loch\f31506  865 ISR(TRX24_AWAKE_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  866 \{
\par \hich\af31506\dbch\af31505\loch\f31506  867 //      DEBUGFLOW('6');
\par \hich\af31506\dbch\af31505\loch\f31506  868         rf230_interruptwait=0;
\par \hich\af31506\dbch\af31505\loch\f31506  869 \}
\par \hich\af31506\dbch\af31505\loch\f31506  870 
\par \hich\af31506\dbch\af31505\loch\f31506  871 /* Transmission has ended */
\par \hich\af31506\dbch\af31505\loch\f31506  872 ISR(TRX24_TX_END_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  873 \{
\par \hich\af31506\dbch\af31505\loch\f31506  874 //      DEBUGFLOW('7');
\par \hich\af31506\dbch\af31505\loch\f31506  875         rf230_interruptwait=0;
\par \hich\af31506\dbch\af31505\loch\f31506  876 \}
\par \hich\af31506\dbch\af31505\loch\f31506  877 
\par \hich\af31506\dbch\af31505\loch\f31506  878 /* Frame address has matched ours */
\par \hich\af31506\dbch\af31505\loch\f31506  879 extern volatile uint8_t rf230_pending;
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 880 ISR(TRX24_XAH_AMI_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 881 \{
\par \hich\af31506\dbch\af31505\loch\f31506  882 //      DEBUGFLOW('8');
\par \hich\af31506\dbch\af31505\loch\f31506  883         rf230_pending=\hich\af31506\dbch\af31505\loch\f31506 1;
\par \hich\af31506\dbch\af31505\loch\f31506  884 \}
\par \hich\af31506\dbch\af31505\loch\f31506  885 
\par \hich\af31506\dbch\af31505\loch\f31506  886 /* CCAED measurement has completed */
\par \hich\af31506\dbch\af31505\loch\f31506  887 ISR(TRX24_CCA_ED_DONE_vect)
\par \hich\af31506\dbch\af31505\loch\f31506  888 \{
\par \hich\af31506\dbch\af31505\loch\f31506  889         DEBUGFLOW('4');
\par \hich\af31506\dbch\af31505\loch\f31506  890         rf230_ccawait=0;
\par \hich\af31506\dbch\af31505\loch\f31506  891 \}
\par \hich\af31506\dbch\af31505\loch\f31506  892 
\par \hich\af31506\dbch\af31505\loch\f31506  893 #else /* defined(__AVR_ATmega128RFA1__) */
\par \hich\af31506\dbch\af31505\loch\f31506  894 /* Separate RF230 has a single r\hich\af31506\dbch\af31505\loch\f31506 adio interrupt and the source must be read from the IRQ_STATUS register */
\par \hich\af31506\dbch\af31505\loch\f31506  895 HAL_RF230_ISR()
\par \hich\af31506\dbch\af31505\loch\f31506  896 \{
\par \hich\af31506\dbch\af31505\loch\f31506  897     /*The following code reads the current system time. This is done by first
\par \hich\af31506\dbch\af31505\loch\f31506  898       reading the hal_system_time and then adding the 16 LSB directly from the
\par \hich\af31506\dbch\af31505\loch\f31506  899       hardware counter.
\par \hich\af31506\dbch\af31505\loch\f31506  900      */
\par \hich\af31506\dbch\af31505\loch\f31506  901 //    uint32_t isr_timestamp = hal_system_time;
\par \hich\af31506\dbch\af31505\loch\f31506  902 //    isr_timestamp <<= 16;
\par \hich\af31506\dbch\af31505\loch\f31506  903 //    isr_timestamp |= HAL_TICK_UPCNT()\hich\af31506\dbch\af31505\loch\f31506 ; // TODO: what if this wraps after reading hal_system_time?
\par \hich\af31506\dbch\af31505\loch\f31506  904 
\par \hich\af31506\dbch\af31505\loch\f31506  905     volatile uint8_t state;
\par \hich\af31506\dbch\af31505\loch\f31506  906     uint8_t interrupt_source; /* used after HAL_SPI_TRANSFER_OPEN/CLOSE block */
\par \hich\af31506\dbch\af31505\loch\f31506  907     INTERRUPTDEBUG(1);
\par \hich\af31506\dbch\af31505\loch\f31506  908 
\par \hich\af31506\dbch\af31505\loch\f31506  909     
\par \hich\af31506\dbch\af31505\loch\f31506  910     /* Using SPI bus \hich\af31506\dbch\af31505\loch\f31506 from ISR is generally a bad idea... */
\par \hich\af31506\dbch\af31505\loch\f31506  911     /* Note: all IRQ are not always automatically disabled when running in ISR */
\par \hich\af31506\dbch\af31505\loch\f31506  912     HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  913 
\par \hich\af31506\dbch\af31505\loch\f31506  914     /*Read Interrupt source.*/
\par \hich\af31506\dbch\af31505\loch\f31506  915     /*Send Register address and read register con\hich\af31506\dbch\af31505\loch\f31506 tent.*/
\par \hich\af31506\dbch\af31505\loch\f31506  916     interrupt_source = HAL_SPI_TRANSFER(0x80 | RG_IRQ_STATUS);
\par \hich\af31506\dbch\af31505\loch\f31506  917 
\par \hich\af31506\dbch\af31505\loch\f31506  918     /* This is the second part of the convertion of system time to a 16 us time
\par \hich\af31506\dbch\af31505\loch\f31506  919        base. The division is moved here so we can spend less time waiting for SPI
\par \hich\af31506\dbch\af31505\loch\f31506  9\hich\af31506\dbch\af31505\loch\f31506 20        data.
\par \hich\af31506\dbch\af31505\loch\f31506  921      */
\par \hich\af31506\dbch\af31505\loch\f31506  922 //   isr_timestamp /= HAL_US_PER_SYMBOL; /* Divide so that we get time in 16us resolution. */
\par \hich\af31506\dbch\af31505\loch\f31506  923 //   isr_timestamp &= HAL_SYMBOL_MASK;
\par \hich\af31506\dbch\af31505\loch\f31506  924 
\par \hich\af31506\dbch\af31505\loch\f31506  925     //HAL_SPI_TRANSFER_WAIT(); /* AFTER possible interleaved processing *\hich\af31506\dbch\af31505\loch\f31506 /
\par \hich\af31506\dbch\af31505\loch\f31506  926 
\par \hich\af31506\dbch\af31505\loch\f31506  927 #if 0 //dak
\par \hich\af31506\dbch\af31505\loch\f31506  928     interrupt_source = HAL_SPI_TRANSFER_READ(); /* The interrupt variable is used as a dummy read. */
\par \hich\af31506\dbch\af31505\loch\f31506  929 
\par \hich\af31506\dbch\af31505\loch\f31506  930     interrupt_source = HAL_SPI_TRANSFER(interrupt_source);
\par \hich\af31506\dbch\af31505\loch\f31506  931 #else
\par \hich\af31506\dbch\af31505\loch\f31506  932     interrupt_source = HAL_SPI_TRANSFER(0);
\par \hich\af31506\dbch\af31505\loch\f31506  933 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  934     HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  935     //PRINTF("i %d\\n", interrupt_source);
\par \hich\af31506\dbch\af31505\loch\f31506  936 
\par \hich\af31506\dbch\af31505\loch\f31506  937     /*Handle the incomming interrupt. Prioritized.*/
\par \hich\af31506\dbch\af31505\loch\f31506  938     if ((interrupt_source & HAL_RX_START_MAS\hich\af31506\dbch\af31505\loch\f31506 K))\{
\par \hich\af31506\dbch\af31505\loch\f31506  939            INTERRUPTDEBUG(10);
\par \hich\af31506\dbch\af31505\loch\f31506  940     /* Save RSSI for this packet if not in extended mode, scaling to 1dB resolution */
\par \hich\af31506\dbch\af31505\loch\f31506  941 #if !RF230_CONF_AUTOACK
\par \hich\af31506\dbch\af31505\loch\f31506  942 #if 0  // 3-clock shift and add is faster on machines with no hardware multiply
\par \hich\af31506\dbch\af31505\loch\f31506  943     \hich\af31506\dbch\af31505\loch\f31506    // With -Os avr-gcc saves a byte by using the general routine for multiply by 3
\par \hich\af31506\dbch\af31505\loch\f31506  944         rf230_last_rssi = hal_subregister_read(SR_RSSI);
\par \hich\af31506\dbch\af31505\loch\f31506  945         rf230_last_rssi = (rf230_last_rssi <<1)  + rf230_last_rssi;
\par \hich\af31506\dbch\af31505\loch\f31506  946 #else  // Faster with 1-clock mul\hich\af31506\dbch\af31505\loch\f31506 tiply. Raven and Jackdaw have 2-clock multiply so same speed while saving 2 bytes of program memory
\par \hich\af31506\dbch\af31505\loch\f31506  947         rf230_last_rssi = 3 * hal_subregister_read(SR_RSSI);
\par \hich\af31506\dbch\af31505\loch\f31506  948 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  949 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  950 //       if(rx_start_callback != NULL)\{
\par \hich\af31506\dbch\af31505\loch\f31506  951 //            /*\hich\af31506\dbch\af31505\loch\f31506  Read Frame length and call rx_start callback. */
\par \hich\af31506\dbch\af31505\loch\f31506  952 //            HAL_SPI_TRANSFER_OPEN();
\par \hich\af31506\dbch\af31505\loch\f31506  953 //            uint8_t frame_length = HAL_SPI_TRANSFER(0x20);
\par \hich\af31506\dbch\af31505\loch\f31506  954 //            frame_length = HAL_SPI_TRANSFER(frame_length);
\par \hich\af31506\dbch\af31505\loch\f31506  955 
\par \hich\af31506\dbch\af31505\loch\f31506  956 //            HAL_SPI_TRANSFER_CLOSE();
\par \hich\af31506\dbch\af31505\loch\f31506  957 
\par \hich\af31506\dbch\af31505\loch\f31506  958 //            rx_start_callback(isr_timestamp, frame_length);
\par \hich\af31506\dbch\af31505\loch\f31506  959 //       \}
\par \hich\af31506\dbch\af31505\loch\f31506  960     \} else if (interrupt_source & HAL_TRX_END_MASK)\{
\par \hich\af31506\dbch\af31505\loch\f31506  961            INTERRUPTDEBUG(11);              
\par \hich\af31506\dbch\af31505\loch\f31506  962 //       \hich\af31506\dbch\af31505\loch\f31506   if(trx_end_callback != NULL)\{
\par \hich\af31506\dbch\af31505\loch\f31506  963 //       trx_end_callback(isr_timestamp);
\par \hich\af31506\dbch\af31505\loch\f31506  964 //     \}
\par \hich\af31506\dbch\af31505\loch\f31506  965         
\par \hich\af31506\dbch\af31505\loch\f31506  966        state = hal_subregister_read(SR_TRX_STATUS);
\par \hich\af31506\dbch\af31505\loch\f31506  967        if((state == BUSY_RX_AACK) || (state == RX_ON) || (state == BUSY_RX) || (state =\hich\af31506\dbch\af31505\loch\f31506 = RX_AACK_ON))\{
\par \hich\af31506\dbch\af31505\loch\f31506  \hich\af31506\dbch\af31505\loch\f31506 968        /* Received packet interrupt */ 
\par \hich\af31506\dbch\af31505\loch\f31506  969        /* Buffer the frame and call rf230_interrupt to schedule poll for rf230 receive process */
\par \hich\af31506\dbch\af31505\loch\f31506  970 //         if (rxframe.length) break;                   //toss packet if last one not p\hich\af31506\dbch\af31505\loch\f31506 rocessed yet
\par \hich\af31506\dbch\af31505\loch\f31506  971          if (rxframe[rxframe_tail].length) INTERRUPTDEBUG(42); else INTERRUPTDEBUG(12);
\par \hich\af31506\dbch\af31505\loch\f31506  972  
\par \hich\af31506\dbch\af31505\loch\f31506  973 #ifdef RF230_MIN_RX_POWER                
\par \hich\af31506\dbch\af31505\loch\f31506  974        /* Discard packets weaker than the minimum if defined. This is for testing miniature\hich\af31506\dbch\af31505\loch\f31506  meshes.*/
\par \hich\af31506\dbch\af31505\loch\f31506  975        /* Save the rssi for printing in the main loop */
\par \hich\af31506\dbch\af31505\loch\f31506  976 #if RF230_CONF_AUTOACK
\par \hich\af31506\dbch\af31505\loch\f31506  977  //       rf230_last_rssi=hal_subregister_read(SR_ED_LEVEL);
\par \hich\af31506\dbch\af31505\loch\f31506  978         rf230_last_rssi=hal_register_read(RG_PHY_ED_LEVEL);
\par \hich\af31506\dbch\af31505\loch\f31506  979 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  980        \hich\af31506\dbch\af31505\loch\f31506  if (rf230_last_rssi >= RF230_MIN_RX_POWER) \{       
\par \hich\af31506\dbch\af31505\loch\f31506  981 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  982          hal_frame_read(&rxframe[rxframe_tail]);
\par \hich\af31506\dbch\af31505\loch\f31506  983          rxframe_tail++;if (rxframe_tail >= RF230_CONF_RX_BUFFERS) rxframe_tail=0;
\par \hich\af31506\dbch\af31505\loch\f31506  984          rf230_interrupt();
\par \hich\af31506\dbch\af31505\loch\f31506  985 //       trx_end_callback(isr_timestamp);
\par \hich\af31506\dbch\af31505\loch\f31506  986 #ifdef RF230_MIN_RX_POWER
\par \hich\af31506\dbch\af31505\loch\f31506  987         \}
\par \hich\af31506\dbch\af31505\loch\f31506  988 #endif
\par \hich\af31506\dbch\af31505\loch\f31506  989 
\par \hich\af31506\dbch\af31505\loch\f31506  990        \}
\par \hich\af31506\dbch\af31505\loch\f31506  991               
\par \hich\af31506\dbch\af31505\loch\f31506  992     \} else if (interrupt_source & HAL_TRX_UR_MASK)\{
\par \hich\af31506\dbch\af31505\loch\f31506  993         INTERRUPTDEBUG(13);
\par \hich\af31506\dbch\af31505\loch\f31506  994         ;
\par \hich\af31506\dbch\af31505\loch\f31506  995  \hich\af31506\dbch\af31505\loch\f31506    \} else if (interrupt_source & HAL_PLL_UNLOCK_MASK)\{
\par \hich\af31506\dbch\af31505\loch\f31506  996         INTERRUPTDEBUG(14);
\par \hich\af31506\dbch\af31505\loch\f31506  997             ;
\par \hich\af31506\dbch\af31505\loch\f31506  998     \} else if (interrupt_source & HAL_PLL_LOCK_MASK)\{
\par \hich\af31506\dbch\af31505\loch\f31506  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang29\langfe1053\langnp29\insrsid10226726 \hich\af31506\dbch\af31505\loch\f31506 999         INTERRUPTDEBUG(15);
\par \hich\af31506\dbch\af31505\loch\f31506 1000 //      hal_pll_lock_flag++;
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 \hich\af31506\dbch\af31505\loch\f31506 1001         ;
\par \hich\af31506\dbch\af31505\loch\f31506 1002    \hich\af31506\dbch\af31505\loch\f31506  \} else if (interrupt_source & HAL_BAT_LOW_MASK)\{
\par \hich\af31506\dbch\af31505\loch\f31506 1003         /*  Disable BAT_LOW interrupt to prevent endless interrupts. The interrupt */
\par \hich\af31506\dbch\af31505\loch\f31506 1004         /*  will continously be asserted while the supply voltage is less than the */
\par \hich\af31506\dbch\af31505\loch\f31506 1005         /*  user-de\hich\af31506\dbch\af31505\loch\f31506 fined voltage threshold. */
\par \hich\af31506\dbch\af31505\loch\f31506 1006         uint8_t trx_isr_mask = hal_register_read(RG_IRQ_MASK);
\par \hich\af31506\dbch\af31505\loch\f31506 1007         trx_isr_mask &= ~HAL_BAT_LOW_MASK;
\par \hich\af31506\dbch\af31505\loch\f31506 1008         hal_register_write(RG_IRQ_MASK, trx_isr_mask);
\par \hich\af31506\dbch\af31505\loch\f31506 1009 //      hal_bat_low_flag++; /* Increment BAT_LO\hich\af31506\dbch\af31505\loch\f31506 W flag. */
\par \hich\af31506\dbch\af31505\loch\f31506 1010         INTERRUPTDEBUG(16);
\par \hich\af31506\dbch\af31505\loch\f31506 1011         ;
\par \hich\af31506\dbch\af31505\loch\f31506 1012      \} else \{
\par \hich\af31506\dbch\af31505\loch\f31506 1013         INTERRUPTDEBUG(99);
\par \hich\af31506\dbch\af31505\loch\f31506 1014             ;
\par \hich\af31506\dbch\af31505\loch\f31506 1015     \}
\par \hich\af31506\dbch\af31505\loch\f31506 1016 \}
\par \hich\af31506\dbch\af31505\loch\f31506 1017 #endif /* defined(__AVR_ATmega128RFA1__) */ 
\par \hich\af31506\dbch\af31505\loch\f31506 1018 #   endif /* defined(DOXYGEN) */
\par \hich\af31506\dbch\af31505\loch\f31506 1019 
\par \hich\af31506\dbch\af31505\loch\f31506 1020 /*----------------------------------------------------------------------------*/
\par \hich\af31506\dbch\af31505\loch\f31506 1021 /* This #if compile switch is used to provide a "standard" function body for the */
\par \hich\af31506\dbch\af31505\loch\f31506 1022 /* doxygen documentation. */
\par \hich\af31506\dbch\af31505\loch\f31506 1023 #if defined(DOXYGEN)
\par \hich\af31506\dbch\af31505\loch\f31506 1024 /** \\brief Timer\hich\af31506\dbch\af31505\loch\f31506  Overflow ISR
\par \hich\af31506\dbch\af31505\loch\f31506 1025  * This is the interrupt service routine for timer1 overflow.
\par \hich\af31506\dbch\af31505\loch\f31506 1026  */
\par \hich\af31506\dbch\af31505\loch\f31506 1027 void TIMER1_OVF_vect(void);
\par \hich\af31506\dbch\af31505\loch\f31506 1028 #else  /* !DOXYGEN */
\par \hich\af31506\dbch\af31505\loch\f31506 1029 HAL_TIME_ISR()
\par \hich\af31506\dbch\af31505\loch\f31506 1030 \{
\par \hich\af31506\dbch\af31505\loch\f31506 1031     hal_system_time++;
\par \hich\af31506\dbch\af31505\loch\f31506 1032 \}
\par \hich\af31506\dbch\af31505\loch\f31506 1033 #endif
\par \hich\af31506\dbch\af31505\loch\f31506 1034 
\par \hich\af31506\dbch\af31505\loch\f31506 1035 /** @\} */
\par \hich\af31506\dbch\af31505\loch\f31506 1036 /** @\}\hich\af31506\dbch\af31505\loch\f31506  */
\par \hich\af31506\dbch\af31505\loch\f31506 1037 
\par \hich\af31506\dbch\af31505\loch\f31506 1038 /*EOF*/}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \lang1033\langfe1053\langnp1033\insrsid10226726\charrsid855868 
\par }{\*\themedata 504b030414000600080000002100e9de0fbfff0000001c020000130000005b436f6e74656e745f54797065735d2e786d6cac91cb4ec3301045f748fc83e52d4a
9cb2400825e982c78ec7a27cc0c8992416c9d8b2a755fbf74cd25442a820166c2cd933f79e3be372bd1f07b5c3989ca74aaff2422b24eb1b475da5df374fd9ad
5689811a183c61a50f98f4babebc2837878049899a52a57be670674cb23d8e90721f90a4d2fa3802cb35762680fd800ecd7551dc18eb899138e3c943d7e503b6
b01d583deee5f99824e290b4ba3f364eac4a430883b3c092d4eca8f946c916422ecab927f52ea42b89a1cd59c254f919b0e85e6535d135a8de20f20b8c12c3b0
0c895fcf6720192de6bf3b9e89ecdbd6596cbcdd8eb28e7c365ecc4ec1ff1460f53fe813d3cc7f5b7f020000ffff0300504b030414000600080000002100a5d6
a7e7c0000000360100000b0000005f72656c732f2e72656c73848fcf6ac3300c87ef85bd83d17d51d2c31825762fa590432fa37d00e1287f68221bdb1bebdb4f
c7060abb0884a4eff7a93dfeae8bf9e194e720169aaa06c3e2433fcb68e1763dbf7f82c985a4a725085b787086a37bdbb55fbc50d1a33ccd311ba548b6309512
0f88d94fbc52ae4264d1c910d24a45db3462247fa791715fd71f989e19e0364cd3f51652d73760ae8fa8c9ffb3c330cc9e4fc17faf2ce545046e37944c69e462
a1a82fe353bd90a865aad41ed0b5b8f9d6fd010000ffff0300504b0304140006000800000021006b799616830000008a0000001c0000007468656d652f746865
6d652f7468656d654d616e616765722e786d6c0ccc4d0ac3201040e17da17790d93763bb284562b2cbaebbf600439c1a41c7a0d29fdbd7e5e38337cedf14d59b
4b0d592c9c070d8a65cd2e88b7f07c2ca71ba8da481cc52c6ce1c715e6e97818c9b48d13df49c873517d23d59085adb5dd20d6b52bd521ef2cdd5eb9246a3d8b
4757e8d3f729e245eb2b260a0238fd010000ffff0300504b03041400060008000000210030dd4329a8060000a41b0000160000007468656d652f7468656d652f
7468656d65312e786d6cec594f6fdb3614bf0fd87720746f6327761a07758ad8b19b2d4d1bc46e871e698996d850a240d2497d1bdae38001c3ba618715d86d87
615b8116d8a5fb34d93a6c1dd0afb0475292c5585e9236d88aad3e2412f9e3fbff1e1fa9abd7eec70c1d1221294fda5efd72cd4324f1794093b0eddd1ef62fad
79482a9c0498f184b4bd2991deb58df7dfbb8ad755446282607d22d771db8b944ad79796a40fc3585ee62949606ecc458c15bc8a702910f808e8c66c69b9565b
5d8a314d3c94e018c8de1a8fa94fd05093f43672e23d06af89927ac06762a049136785c10607758d9053d965021d62d6f6804fc08f86e4bef210c352c144dbab
999fb7b4717509af678b985ab0b6b4ae6f7ed9ba6c4170b06c788a705430adf71bad2b5b057d03606a1ed7ebf5babd7a41cf00b0ef83a6569632cd467faddec9
699640f6719e76b7d6ac355c7c89feca9cccad4ea7d36c65b258a206641f1b73f8b5da6a6373d9c11b90c537e7f08dce66b7bbeae00dc8e257e7f0fd2badd586
8b37a088d1e4600ead1ddaef67d40bc898b3ed4af81ac0d76a197c86826828a24bb318f3442d8ab518dfe3a20f000d6458d104a9694ac6d88728eee2782428d6
0cf03ac1a5193be4cbb921cd0b495fd054b5bd0f530c1931a3f7eaf9f7af9e3f45c70f9e1d3ff8e9f8e1c3e3073f5a42ceaa6d9c84e5552fbffdeccfc71fa33f
9e7ef3f2d117d57859c6fffac327bffcfc793510d26726ce8b2f9ffcf6ecc98baf3efdfdbb4715f04d814765f890c644a29be408edf3181433567125272371be
15c308d3f28acd249438c19a4b05fd9e8a1cf4cd296699771c393ac4b5e01d01e5a30a787d72cf1178108989a2159c77a2d801ee72ce3a5c545a6147f32a9979
3849c26ae66252c6ed637c58c5bb8b13c7bfbd490a75330f4b47f16e441c31f7184e140e494214d273fc80900aedee52ead87597fa824b3e56e82e451d4c2b4d
32a423279a668bb6690c7e9956e90cfe766cb37b077538abd27a8b1cba48c80acc2a841f12e698f13a9e281c57911ce298950d7e03aba84ac8c154f8655c4f2a
f074481847bd804859b5e696007d4b4edfc150b12addbecba6b18b148a1e54d1bc81392f23b7f84137c2715a851dd0242a633f900710a218ed715505dfe56e86
e877f0034e16bafb0e258ebb4faf06b769e888340b103d331115bebc4eb813bf83291b63624a0d1475a756c734f9bbc2cd28546ecbe1e20a3794ca175f3fae90
fb6d2dd99bb07b55e5ccf68942bd0877b23c77b908e8db5f9db7f024d9239010f35bd4bbe2fcae387bfff9e2bc289f2fbe24cfaa301468dd8bd846dbb4ddf1c2
ae7b4c191ba8292337a469bc25ec3d411f06f53a73e224c5292c8de0516732307070a1c0660d125c7d44553488700a4d7bddd3444299910e254ab984c3a219ae
a4adf1d0f82b7bd46cea4388ad1c12ab5d1ed8e1153d9c9f350a3246aad01c6873462b9ac05999ad5cc988826eafc3acae853a33b7ba11cd1445875ba1b236b1
399483c90bd560b0b0263435085a21b0f22a9cf9356b38ec6046026d77eba3dc2dc60b17e92219e180643ed27acffba86e9c94c7ca9c225a0f1b0cfae0788ad5
4adc5a9aec1b703b8b93caec1a0bd8e5de7b132fe5113cf312503b998e2c2927274bd051db6b35979b1ef271daf6c6704e86c73805af4bdd476216c26593af84
0dfb5393d964f9cc9bad5c313709ea70f561ed3ea7b053075221d51696910d0d339585004b34272bff7213cc7a510a5454a3b349b1b206c1f0af490176745d4b
c663e2abb2b34b23da76f6352ba57ca2881844c1111ab189d8c7e07e1daaa04f40255c77988aa05fe06e4e5bdb4cb9c5394bbaf28d98c1d971ccd20867e556a7
689ec9166e0a522183792b8907ba55ca6e943bbf2a26e52f48957218ffcf54d1fb09dc3eac04da033e5c0d0b8c74a6b43d2e54c4a10aa511f5fb021a07533b20
5ae07e17a621a8e082dafc17e450ffb739676998b48643a4daa7211214f623150942f6a02c99e83b85583ddbbb2c4996113211551257a656ec1139246ca86be0
aadedb3d1441a89b6a929501833b197fee7b9641a3503739e57c732a59b1f7da1cf8a73b1f9bcca0945b874d4393dbbf10b1680f66bbaa5d6f96e77b6f59113d
316bb31a795600b3d256d0cad2fe354538e7566b2bd69cc6cbcd5c38f0e2bcc63058344429dc2121fd07f63f2a7c66bf76e80d75c8f7a1b622f878a18941d840
545fb28d07d205d20e8ea071b283369834296bdaac75d256cb37eb0bee740bbe278cad253b8bbfcf69eca23973d939b97891c6ce2cecd8da8e2d343578f6648a
c2d0383fc818c798cf64e52f597c740f1cbd05df0c264c49134cf09d4a60e8a107260f20f92d47b374e32f000000ffff0300504b030414000600080000002100
0dd1909fb60000001b010000270000007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73848f4d0ac2301484f7
8277086f6fd3ba109126dd88d0add40384e4350d363f2451eced0dae2c082e8761be9969bb979dc9136332de3168aa1a083ae995719ac16db8ec8e4052164e89
d93b64b060828e6f37ed1567914b284d262452282e3198720e274a939cd08a54f980ae38a38f56e422a3a641c8bbd048f7757da0f19b017cc524bd62107bd500
1996509affb3fd381a89672f1f165dfe514173d9850528a2c6cce0239baa4c04ca5bbabac4df000000ffff0300504b01022d0014000600080000002100e9de0f
bfff0000001c0200001300000000000000000000000000000000005b436f6e74656e745f54797065735d2e786d6c504b01022d0014000600080000002100a5d6
a7e7c0000000360100000b00000000000000000000000000300100005f72656c732f2e72656c73504b01022d00140006000800000021006b799616830000008a
0000001c00000000000000000000000000190200007468656d652f7468656d652f7468656d654d616e616765722e786d6c504b01022d00140006000800000021
0030dd4329a8060000a41b00001600000000000000000000000000d60200007468656d652f7468656d652f7468656d65312e786d6c504b01022d001400060008
00000021000dd1909fb60000001b0100002700000000000000000000000000b20900007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73504b050600000000050005005d010000ad0a00000000}
{\*\colorschememapping 3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d3822207374616e64616c6f6e653d22796573223f3e0d0a3c613a636c724d
617020786d6c6e733a613d22687474703a2f2f736368656d61732e6f70656e786d6c666f726d6174732e6f72672f64726177696e676d6c2f323030362f6d6169
6e22206267313d226c743122207478313d22646b3122206267323d226c743222207478323d22646b322220616363656e74313d22616363656e74312220616363
656e74323d22616363656e74322220616363656e74333d22616363656e74332220616363656e74343d22616363656e74342220616363656e74353d22616363656e74352220616363656e74363d22616363656e74362220686c696e6b3d22686c696e6b2220666f6c486c696e6b3d22666f6c486c696e6b222f3e}
{\*\latentstyles\lsdstimax267\lsdlockeddef0\lsdsemihiddendef1\lsdunhideuseddef1\lsdqformatdef0\lsdprioritydef99{\lsdlockedexcept \lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority0 \lsdlocked0 Normal;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 1;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 2;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 3;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 4;
\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 5;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 6;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 7;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 8;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 9;
\lsdpriority39 \lsdlocked0 toc 1;\lsdpriority39 \lsdlocked0 toc 2;\lsdpriority39 \lsdlocked0 toc 3;\lsdpriority39 \lsdlocked0 toc 4;\lsdpriority39 \lsdlocked0 toc 5;\lsdpriority39 \lsdlocked0 toc 6;\lsdpriority39 \lsdlocked0 toc 7;
\lsdpriority39 \lsdlocked0 toc 8;\lsdpriority39 \lsdlocked0 toc 9;\lsdqformat1 \lsdpriority35 \lsdlocked0 caption;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority10 \lsdlocked0 Title;\lsdpriority1 \lsdlocked0 Default Paragraph Font;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority11 \lsdlocked0 Subtitle;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority22 \lsdlocked0 Strong;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority20 \lsdlocked0 Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority59 \lsdlocked0 Table Grid;\lsdunhideused0 \lsdlocked0 Placeholder Text;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority1 \lsdlocked0 No Spacing;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 1;\lsdunhideused0 \lsdlocked0 Revision;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority34 \lsdlocked0 List Paragraph;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority29 \lsdlocked0 Quote;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority30 \lsdlocked0 Intense Quote;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority19 \lsdlocked0 Subtle Emphasis;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority21 \lsdlocked0 Intense Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority31 \lsdlocked0 Subtle Reference;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority32 \lsdlocked0 Intense Reference;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority33 \lsdlocked0 Book Title;\lsdpriority37 \lsdlocked0 Bibliography;\lsdqformat1 \lsdpriority39 \lsdlocked0 TOC Heading;}}{\*\datastore 010500000200000018000000
4d73786d6c322e534158584d4c5265616465722e362e3000000000000000000000060000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001000000010000000000000000100000feffffff00000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffffffffffff0c6ad98892f1d411a65f0040963251e50000000000000000000000005028
31a045ebce01feffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000105000000000000}}